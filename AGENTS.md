**Stage 1**

- core/access_control.go  
- core/access_control_test.go  
- core/address.go  
- core/address_zero.go  
- core/address_zero_test.go  
- core/ai_enhanced_contract.go  
- core/ai_enhanced_contract_test.go  
- core/audit_management.go  
- core/audit_management_test.go  
- core/audit_node.go  
- core/audit_node_test.go  
- core/authority_apply.go  
- core/authority_apply_test.go  
- core/authority_node_index.go  
- core/authority_node_index_test.go  

**Stage 2**

- core/authority_nodes.go  
- core/authority_nodes_test.go  
- core/bank_institutional_node.go  
- core/bank_nodes_index.go  
- core/bank_nodes_test.go  
- core/base_node.go  
- core/base_node_test.go  
- core/biometric.go  
- core/biometric_security_node.go  
- core/biometric_security_node_test.go  
- core/biometric_test.go  
- core/biometrics_auth.go  
- core/biometrics_auth_test.go  
- core/block.go  
- core/block_test.go  

**Stage 3**

- core/blockchain_compression.go  
- core/blockchain_compression_test.go  
- core/blockchain_synchronization.go  
- core/blockchain_synchronization_test.go  
- core/central_banking_node.go  
- core/charity.go  
- core/coin.go  
- core/coin_test.go  
- core/compliance.go  
- core/compliance_management.go  
- core/compliance_management_test.go  
- core/compliance_test.go  
- core/connection_pool.go  
- core/connection_pool_test.go  
- core/consensus.go  

**Stage 4**

- core/consensus_adaptive_management.go  
- core/consensus_adaptive_management_test.go  
- core/consensus_difficulty.go  
- core/consensus_difficulty_test.go  
- core/consensus_specific.go  
- core/consensus_specific_node.go  
- core/consensus_specific_node_test.go  
- core/consensus_specific_test.go  
- core/consensus_start.go  
- core/consensus_start_test.go  
- core/consensus_test.go  
- core/consensus_validator_management.go  
- core/consensus_validator_management_test.go  
- core/contract_management.go  
- core/contract_management_test.go  

**Stage 5**

- core/contracts.go  
- core/contracts_opcodes.go  
- core/contracts_test.go  
- core/cross_chain.go  
- core/cross_chain_agnostic_protocols.go  
- core/cross_chain_agnostic_protocols_test.go  
- core/cross_chain_bridge.go  
- core/cross_chain_bridge_test.go  
- core/cross_chain_connection.go  
- core/cross_chain_connection_test.go  
- core/cross_chain_contracts.go  
- core/cross_chain_contracts_test.go  
- core/cross_chain_test.go  
- core/cross_chain_transactions.go  
- core/cross_chain_transactions_test.go  

**Stage 6**

- core/cross_consensus_scaling_networks.go  
- core/cross_consensus_scaling_networks_test.go  
- core/custodial_node.go  
- core/dao.go  
- core/dao_access_control.go  
- core/dao_access_control_test.go  
- core/dao_proposal.go  
- core/dao_proposal_test.go  
- core/dao_quadratic_voting.go  
- core/dao_quadratic_voting_test.go  
- core/dao_staking.go  
- core/dao_staking_test.go  
- core/dao_test.go  
- core/dao_token.go  
- core/dao_token_test.go  

**Stage 7**

- core/elected_authority_node.go  
- core/elected_authority_node_test.go  
- core/faucet.go  
- core/faucet_test.go  
- core/fees.go  
- core/fees_test.go  
- core/firewall.go  
- core/forensic_node.go  
- core/forensic_node_test.go  
- core/full_node.go  
- core/full_node_test.go  
- core/gas.go  
- core/gas_table.go  
- core/gas_test.go  
- core/gateway_node.go  

**Stage 8**

- core/gateway_node_test.go  
- core/genesis_wallets.go  
- core/genesis_wallets_test.go  
- core/government_authority_node.go  
- core/government_authority_node_test.go  
- core/high_availability.go  
- core/historical_node.go  
- core/historical_node_test.go  
- core/identity_verification.go  
- core/identity_verification_test.go  
- core/idwallet_registration.go  
- core/idwallet_registration_test.go  
- core/immutability_enforcement.go  
- core/immutability_enforcement_test.go  
- core/initialization_replication.go  

**Stage 9**

- core/initialization_replication_test.go  
- core/instruction.go  
- core/kademlia.go  
- core/kademlia_test.go  
- core/ledger.go  
- core/ledger_test.go  
- core/light_node.go  
- core/light_node_test.go  
- core/liquidity_pools.go  
- core/liquidity_pools_test.go  
- core/liquidity_views.go  
- core/loanpool.go  
- core/loanpool_apply.go  
- core/loanpool_management.go  
- core/loanpool_proposal.go  

**Stage 10**

- core/loanpool_test.go  
- core/loanpool_views.go  
- core/mining_node.go  
- core/mining_node_test.go  
- core/mobile_mining_node.go  
- core/mobile_mining_node_test.go  
- core/nat_traversal.go  
- core/nat_traversal_test.go  
- core/network.go  
- core/network_test.go  
- core/node.go  
- core/node_adapter.go  
- core/node_test.go  
- core/opcode.go  
- core/opcodes_base.go  

**Stage 11**

- core/peer_management.go  
- core/peer_management_test.go  
- core/plasma.go  
- core/plasma_management.go  
- core/plasma_management_test.go  
- core/plasma_operations.go  
- core/plasma_operations_test.go  
- core/private_transactions.go  
- core/private_transactions_test.go  
- core/quorum_tracker.go  
- core/quorum_tracker_test.go  
- core/regulatory_management.go  
- core/regulatory_management_test.go  
- core/regulatory_node.go  
- core/regulatory_node_test.go  
- core/replication.go  

**Stage 12**

- core/replication_test.go  
- core/rollup_management.go  
- core/rollup_management_test.go  
- core/rollups.go  
- core/rollups_test.go  
- core/rpc_webrtc.go  
- core/rpc_webrtc_test.go  
- core/security_test.go  
- core/sharding.go  
- core/sharding_test.go  
- core/sidechain_ops.go  
- core/sidechain_ops_test.go  
- core/sidechains.go  
- core/sidechains_test.go  
- core/snvm.go  

**Stage 13**

- core/snvm_test.go  
- core/stake_penalty.go  
- core/stake_penalty_test.go  
- core/staking_node.go  
- core/staking_node_test.go  
- core/state_rw.go  
- core/swarm.go  
- core/swarm_test.go  
- core/syn1300.go  
- core/syn131_token.go  
- core/syn1401.go  
- core/syn1401_test.go  
- core/syn1600.go  
- core/syn1600_test.go  
- core/syn1700_token.go  

**Stage 14**

- core/syn1700_token_test.go  
- core/syn2100.go  
- core/syn2100_test.go  
- core/syn223_token.go  
- core/syn2500_token.go  
- core/syn2700.go  
- core/syn2700_test.go  
- core/syn2900.go  
- core/syn2900_test.go  
- core/syn300_token.go  
- core/syn3200.go  
- core/syn3500_token.go  
- core/syn3600.go  
- core/syn3600_test.go  
- core/syn3700_token.go  

**Stage 15**

- core/syn3800.go  
- core/syn3800_test.go  
- core/syn3900.go  
- core/syn3900_test.go  
- core/syn4200_token.go  
- core/syn4700.go  
- core/syn500.go  
- core/syn5000.go  
- core/syn5000_index.go  
- core/syn5000_test.go  
- core/syn700.go  
- core/syn800_token.go  
- core/system_health_logging.go  
- core/token_syn130.go  
- core/token_syn4900.go  

**Stage 16**

- core/transaction.go  
- core/transaction_control.go  
- core/transaction_control_test.go  
- core/transaction_test.go  
- core/validator_node.go  
- core/validator_node_test.go  
- core/virtual_machine.go  
- core/virtual_machine_test.go  
- core/vm_sandbox_management.go  
- core/vm_sandbox_management_test.go  
- core/wallet.go  
- core/wallet_test.go  
- core/warfare_node.go  
- core/warfare_node_test.go  
- core/watchtower_node.go  

**Stage 17**

- core/zero_trust_data_channels.go  
- core/zero_trust_data_channels_test.go  
- internal/nodes/README.md  
- internal/nodes/authority_nodes/index.go  
- internal/nodes/authority_nodes/index_test.go  
- internal/nodes/bank_nodes/index.go  
- internal/nodes/bank_nodes/index_test.go  
- internal/nodes/consensus_specific.go  
- internal/nodes/consensus_specific_test.go  
- internal/nodes/elected_authority_node.go  
- internal/nodes/elected_authority_node_test.go  
- internal/nodes/experimental_node.go  
- internal/nodes/extra/forensic_node.go  
- internal/nodes/extra/geospatial.go  
- internal/nodes/extra/historical_node.go  

**Stage 18**

- internal/nodes/extra/holographic_node.go  
- internal/nodes/extra/index.go  
- internal/nodes/extra/military_nodes/index.go  
- internal/nodes/extra/optimization_nodes/index.go  
- internal/nodes/extra/optimization_nodes/optimization.go  
- internal/nodes/extra/watchtower/index.go  
- internal/nodes/forensic_node.go  
- internal/nodes/geospatial.go  
- internal/nodes/historical_node.go  
- internal/nodes/holographic_node.go  
- internal/nodes/holographic_node_test.go  
- internal/nodes/index.go  
- internal/nodes/light_node.go  
- internal/nodes/military_nodes/index.go  
- internal/nodes/optimization_nodes/index.go  

**Stage 19**

- internal/nodes/optimization_nodes/optimization.go  
- internal/nodes/types.go  
- internal/nodes/watchtower/index.go  
- internal/tokens/README.md  
- internal/tokens/advanced_tokens_test.go  
- internal/tokens/base.go  
- internal/tokens/base_test.go  
- internal/tokens/dao_tokens_test.go  
- internal/tokens/index.go  
- internal/tokens/syn10.go  
- internal/tokens/syn1000.go  
- internal/tokens/syn1000_index.go  
- internal/tokens/syn1100.go  
- internal/tokens/syn12.go  
- internal/tokens/syn20.go  

**Stage 20**

- internal/tokens/syn200.go  
- internal/tokens/syn223_token.go  
- internal/tokens/syn2369.go  
- internal/tokens/syn2500_token.go  
- internal/tokens/syn2600.go  
- internal/tokens/syn2800.go  
- internal/tokens/syn2900.go  
- internal/tokens/syn300_token.go  
- internal/tokens/syn3400.go  
- internal/tokens/syn3500_token.go  
- internal/tokens/syn3700_token.go  
- internal/tokens/syn4200_token.go  
- internal/tokens/syn4700.go  
- internal/tokens/syn70.go  
- internal/tokens/syn845.go  

The file paths above were compiled from the repositoryâ€™s core, node, and token areas using command-line listings

## Function List

```
./zero_trust_data_channels.go:22:func NewZeroTrustEngine() *ZeroTrustEngine {
./zero_trust_data_channels.go:27:func (e *ZeroTrustEngine) OpenChannel(id string, key []byte) error {
./zero_trust_data_channels.go:38:func (e *ZeroTrustEngine) Send(id string, payload []byte) ([]byte, error) {
./zero_trust_data_channels.go:56:func (e *ZeroTrustEngine) Messages(id string) [][]byte {
./zero_trust_data_channels.go:73:func (e *ZeroTrustEngine) CloseChannel(id string) error {
./virtual_machine.go:42:func NewSimpleVM(modes ...VMMode) *SimpleVM {
./virtual_machine.go:75:func (vm *SimpleVM) Start() error {
./virtual_machine.go:86:func (vm *SimpleVM) Stop() error {
./virtual_machine.go:97:func (vm *SimpleVM) Status() bool {
./virtual_machine.go:106:func (vm *SimpleVM) Execute(wasm []byte, method string, args []byte, gasLimit uint64) ([]byte, uint64, error) {
./regulatory_node.go:14:func NewRegulatoryNode(id string, mgr *RegulatoryManager) *RegulatoryNode {
./regulatory_node.go:23:func (n *RegulatoryNode) ApproveTransaction(tx Transaction) bool {
./regulatory_node.go:29:func (n *RegulatoryNode) FlagEntity(addr, reason string) {
./regulatory_node.go:36:func (n *RegulatoryNode) Logs(addr string) []string {
./vm_sandbox_management.go:29:func NewSandboxManager() *SandboxManager {
./vm_sandbox_management.go:34:func (m *SandboxManager) StartSandbox(id, contractAddr string, gasLimit, memoryLimit uint64) (*SandboxInfo, error) {
./vm_sandbox_management.go:54:func (m *SandboxManager) StopSandbox(id string) error {
./vm_sandbox_management.go:66:func (m *SandboxManager) ResetSandbox(id string) error {
./vm_sandbox_management.go:78:func (m *SandboxManager) SandboxStatus(id string) (*SandboxInfo, bool) {
./vm_sandbox_management.go:86:func (m *SandboxManager) ListSandboxes() []*SandboxInfo {
./stake_penalty.go:27:func NewStakePenaltyManager() *StakePenaltyManager {
./stake_penalty.go:37:func (m *StakePenaltyManager) AdjustStake(addr string, delta int64) {
./stake_penalty.go:48:func (m *StakePenaltyManager) Penalize(addr string, points int, reason string) {
./stake_penalty.go:58:func (m *StakePenaltyManager) Info(addr string) (stake uint64, penalty int, history []PenaltyRecord) {
./mining_node.go:26:func NewMiningNode(id string, hashRate float64) *MiningNode {
./mining_node.go:31:func (m *MiningNode) ID() string {
./mining_node.go:37:func (m *MiningNode) Start() {
./mining_node.go:50:func (m *MiningNode) Stop() {
./mining_node.go:57:func (m *MiningNode) IsRunning() bool {
./mining_node.go:64:func (m *MiningNode) HashRate() float64 {
./mining_node.go:72:func (m *MiningNode) SubmitBlock(hash string) {
./mining_node.go:79:func (m *MiningNode) LastBlock() string {
./mining_node.go:87:func (m *MiningNode) mineLoop() {
./mining_node.go:108:func randomHash() string {
./mining_node.go:118:func (m *MiningNode) MineBlock(difficulty int) (string, error) {
./internal/tokens/syn4200_token.go:21:func NewSYN4200Token() *SYN4200Token {
./internal/tokens/syn4200_token.go:26:func (t *SYN4200Token) Donate(symbol, from string, amount uint64, purpose string) {
./internal/tokens/syn4200_token.go:43:func (t *SYN4200Token) CampaignProgress(symbol string) (uint64, bool) {
./internal/tokens/syn4200_token.go:54:func (t *SYN4200Token) Campaign(symbol string) (*CharityCampaign, bool) {
./internal/tokens/syn300_token.go:30:func NewSYN300Token(initial map[string]uint64) *SYN300Token {
./internal/tokens/syn300_token.go:44:func (t *SYN300Token) Delegate(owner, delegate string) {
./internal/tokens/syn300_token.go:55:func (t *SYN300Token) RevokeDelegation(owner string) {
./internal/tokens/syn300_token.go:62:func (t *SYN300Token) VotingPower(addr string) uint64 {
./internal/tokens/syn300_token.go:68:func (t *SYN300Token) votingPowerLocked(addr string) uint64 {
./internal/tokens/syn300_token.go:79:func (t *SYN300Token) CreateProposal(creator, description string) uint64 {
./internal/tokens/syn300_token.go:96:func (t *SYN300Token) Vote(id uint64, voter string, approve bool) error {
./internal/tokens/syn300_token.go:117:func (t *SYN300Token) Execute(id uint64, quorum uint64) error {
./internal/tokens/syn300_token.go:139:func (t *SYN300Token) ProposalStatus(id uint64) (*GovernanceProposal, error) {
./internal/tokens/syn300_token.go:159:func (t *SYN300Token) ListProposals() []*GovernanceProposal {
./internal/tokens/syn2500_token.go:18:func NewSyn2500Member(id, addr string, power uint64, meta map[string]string) *Syn2500Member {
./internal/tokens/syn2500_token.go:33:func (m *Syn2500Member) UpdateVotingPower(power uint64) {
./internal/tokens/syn2500_token.go:44:func NewSyn2500Registry() *Syn2500Registry {
./internal/tokens/syn2500_token.go:49:func (r *Syn2500Registry) AddMember(m *Syn2500Member) {
./internal/tokens/syn2500_token.go:56:func (r *Syn2500Registry) GetMember(id string) (*Syn2500Member, bool) {
./internal/tokens/syn2500_token.go:64:func (r *Syn2500Registry) RemoveMember(id string) {
./internal/tokens/syn2500_token.go:71:func (r *Syn2500Registry) ListMembers() []*Syn2500Member {
./internal/tokens/syn20.go:13:func NewSYN20Token(id TokenID, name, symbol string, decimals uint8) *SYN20Token {
./internal/tokens/syn20.go:21:func (t *SYN20Token) Pause() { t.paused = true }
./internal/tokens/syn20.go:24:func (t *SYN20Token) Unpause() { t.paused = false }
./internal/tokens/syn20.go:27:func (t *SYN20Token) Freeze(addr string) { t.frozen[addr] = true }
./internal/tokens/syn20.go:30:func (t *SYN20Token) Unfreeze(addr string) { delete(t.frozen, addr) }
./internal/tokens/syn20.go:33:func (t *SYN20Token) Transfer(from, to string, amount uint64) error {
./internal/tokens/syn20.go:44:func (t *SYN20Token) Mint(to string, amount uint64) error {
./internal/tokens/syn20.go:52:func (t *SYN20Token) Burn(from string, amount uint64) error {
./internal/tokens/syn1000.go:16:func NewSYN1000Token(id TokenID, name, symbol string, decimals uint8) *SYN1000Token {
./internal/tokens/syn1000.go:24:func (t *SYN1000Token) AddReserve(asset string, amount float64) {
./internal/tokens/syn1000.go:31:func (t *SYN1000Token) SetReservePrice(asset string, price float64) {
./internal/tokens/syn1000.go:38:func (t *SYN1000Token) TotalReserveValue() float64 {
./internal/p2p/tls_transport.go:17:func NewTLSTransport(cert tls.Certificate, caPool *x509.CertPool, server bool) *TLSTransport {
./internal/p2p/tls_transport.go:33:func (t *TLSTransport) Dial(ctx context.Context, addr string) (net.Conn, error) {
./internal/p2p/tls_transport.go:42:func (t *TLSTransport) Listen(ctx context.Context, addr string) (net.Listener, error) {
./internal/nodes/extra/optimization_nodes/optimization.go:25:func (o *SimpleOptimizer) Optimize(m Metrics) Suggestion {
./internal/nodes/extra/holographic_node.go:17:func NewHolographicNode(id string) *HolographicNode {
./internal/nodes/extra/holographic_node.go:25:func (n *HolographicNode) ID() string { return n.id }
./internal/nodes/extra/holographic_node.go:29:func (n *HolographicNode) Start() error { return nil }
./internal/nodes/extra/holographic_node.go:33:func (n *HolographicNode) Stop() error { return nil }
./internal/nodes/extra/holographic_node.go:36:func (n *HolographicNode) Store(frame synnergy.HolographicFrame) {
./internal/nodes/extra/holographic_node.go:44:func (n *HolographicNode) Retrieve(id string) (synnergy.HolographicFrame, bool) {
./internal/nodes/experimental_node.go:15:func NewExperimentalNode(id Address) *ExperimentalNode {
./internal/nodes/experimental_node.go:20:func (n *ExperimentalNode) ID() Address { return n.id }
./internal/nodes/experimental_node.go:23:func (n *ExperimentalNode) Start() error {
./internal/nodes/experimental_node.go:29:func (n *ExperimentalNode) Stop() error {
./internal/nodes/experimental_node.go:35:func (n *ExperimentalNode) IsRunning() bool { return n.running }
./internal/nodes/experimental_node.go:38:func (n *ExperimentalNode) Peers() []Address { return nil }
./internal/nodes/experimental_node.go:41:func (n *ExperimentalNode) DialSeed(addr Address) error { return nil }
./internal/nodes/authority_nodes/index.go:19:func NewIndex() *Index {
./internal/nodes/authority_nodes/index.go:24:func (idx *Index) Add(node *AuthorityNode) {
./internal/nodes/authority_nodes/index.go:34:func (idx *Index) Get(addr string) (*AuthorityNode, bool) {
./internal/nodes/authority_nodes/index.go:42:func (idx *Index) Remove(addr string) {
./internal/nodes/authority_nodes/index.go:49:func (idx *Index) List() []*AuthorityNode {
./internal/config/config.go:39:func Load(path string) (*Config, error) {
./idwallet_registration.go:15:func NewIDRegistry() *IDRegistry {
./idwallet_registration.go:20:func (r *IDRegistry) Register(addr, info string) error {
./idwallet_registration.go:31:func (r *IDRegistry) Info(addr string) (string, bool) {
./idwallet_registration.go:39:func (r *IDRegistry) IsRegistered(addr string) bool {
./geospatial_node.go:23:func NewGeospatialNode() *GeospatialNode {
./geospatial_node.go:28:func (n *GeospatialNode) Record(subject string, lat, lon float64) {
./geospatial_node.go:40:func (n *GeospatialNode) History(subject string) []GeoRecord {
./environmental_monitoring_node.go:17:func (c EnvCondition) Evaluate(data []byte) bool {
./environmental_monitoring_node.go:45:func NewEnvironmentalMonitoringNode() *EnvironmentalMonitoringNode {
./environmental_monitoring_node.go:50:func (n *EnvironmentalMonitoringNode) SetCondition(c EnvCondition) {
./environmental_monitoring_node.go:57:func (n *EnvironmentalMonitoringNode) Trigger(sensorID string, data []byte) bool {
./data_resource_management.go:15:func NewDataResourceManager() *DataResourceManager {
./data_resource_management.go:20:func (m *DataResourceManager) Put(key string, data []byte) {
./data_resource_management.go:32:func (m *DataResourceManager) Get(key string) ([]byte, bool) {
./data_resource_management.go:45:func (m *DataResourceManager) Delete(key string) {
./data_resource_management.go:55:func (m *DataResourceManager) Keys() []string {
./data_resource_management.go:66:func (m *DataResourceManager) Usage() int64 {
./cross_chain_transactions.go:29:func NewTransactionManager() *TransactionManager {
./cross_chain_transactions.go:34:func (m *TransactionManager) LockAndMint(bridgeID, assetID string, amount uint64, proof string) string {
./cross_chain_transactions.go:51:func (m *TransactionManager) BurnAndRelease(bridgeID, to, assetID string, amount uint64) string {
./cross_chain_transactions.go:68:func (m *TransactionManager) ListTransactions() []CrossChainTransaction {
./cross_chain_transactions.go:79:func (m *TransactionManager) GetTransaction(id string) (CrossChainTransaction, bool) {
./cross_chain_agnostic_protocols.go:23:func NewProtocolRegistry() *ProtocolRegistry {
./cross_chain_agnostic_protocols.go:28:func (r *ProtocolRegistry) RegisterProtocol(name string) string {
./cross_chain_agnostic_protocols.go:37:func (r *ProtocolRegistry) ListProtocols() []CrossChainProtocol {
./cross_chain_agnostic_protocols.go:48:func (r *ProtocolRegistry) GetProtocol(id string) (CrossChainProtocol, bool) {
./core/warfare_node.go:19:func NewWarfareNode(base *Node) *WarfareNode {
./core/warfare_node.go:24:func (w *WarfareNode) GetID() string {
./core/warfare_node.go:33:func (w *WarfareNode) SecureCommand(cmd string) error {
./core/warfare_node.go:41:func (w *WarfareNode) TrackLogistics(assetID, location, status string) {
./core/warfare_node.go:55:func (w *WarfareNode) ShareTactical(info string) {
./core/warfare_node.go:61:func (w *WarfareNode) Logistics() []militarynodes.LogisticsRecord {
./core/warfare_node.go:71:func (w *WarfareNode) LogisticsByAsset(assetID string) []militarynodes.LogisticsRecord {
./core/validator_node.go:12:func NewValidatorNode(id, addr string, ledger *Ledger, minStake uint64, quorum int) *ValidatorNode {
./core/validator_node.go:22:func (vn *ValidatorNode) AddValidator(addr string, stake uint64) error {
./core/validator_node.go:31:func (vn *ValidatorNode) RemoveValidator(addr string) {
./core/validator_node.go:37:func (vn *ValidatorNode) SlashValidator(addr string) {
./core/validator_node.go:44:func (vn *ValidatorNode) HasQuorum() bool {
./core/token_syn130.go:40:func NewTangibleAssetRegistry() *TangibleAssetRegistry {
./core/token_syn130.go:45:func (r *TangibleAssetRegistry) Register(id, owner, meta string, value uint64) (*TangibleAsset, error) {
./core/token_syn130.go:55:func (r *TangibleAssetRegistry) UpdateValuation(id string, val uint64) error {
./core/token_syn130.go:65:func (r *TangibleAssetRegistry) RecordSale(id, buyer string, price uint64) error {
./core/token_syn130.go:76:func (r *TangibleAssetRegistry) StartLease(id, lessee string, payment uint64, start, end time.Time) error {
./core/token_syn130.go:86:func (r *TangibleAssetRegistry) EndLease(id string) error {
./core/token_syn130.go:98:func (r *TangibleAssetRegistry) Get(id string) (*TangibleAsset, bool) {
./core/syn4200_token.go:23:func NewSYN4200Token() *SYN4200Token {
./core/syn4200_token.go:28:func (t *SYN4200Token) Donate(symbol, from string, amount uint64, purpose string) {
./core/syn4200_token.go:45:func (t *SYN4200Token) CampaignProgress(symbol string) (uint64, bool) {
./core/syn4200_token.go:56:func (t *SYN4200Token) Campaign(symbol string) (*CharityCampaign, bool) {
./core/syn3600.go:19:func NewFuturesContract(underlying string, quantity, price uint64, expiration time.Time) *FuturesContract {
./core/syn3600.go:24:func (f *FuturesContract) IsExpired(now time.Time) bool {
./core/syn3600.go:29:func (f *FuturesContract) Settle(marketPrice uint64) int64 {
./core/syn2900.go:23:func NewTokenInsurancePolicy(id, holder, coverage string, premium, payout, deductible, limit uint64, start, end time.Time) *TokenInsurancePolicy {
./core/syn2900.go:38:func (p *TokenInsurancePolicy) IsActive(now time.Time) bool {
./core/syn2900.go:43:func (p *TokenInsurancePolicy) Claim(now time.Time) (uint64, error) {
./core/syn2100.go:30:func NewTradeFinanceToken() *TradeFinanceToken {
./core/syn2100.go:38:func (t *TradeFinanceToken) RegisterDocument(docID, issuer, recipient string, amount uint64, issue, due time.Time, desc string) {
./core/syn2100.go:53:func (t *TradeFinanceToken) FinanceDocument(docID, financier string) error {
./core/syn2100.go:69:func (t *TradeFinanceToken) GetDocument(docID string) (*FinancialDocument, bool) {
./core/syn2100.go:81:func (t *TradeFinanceToken) ListDocuments() []*FinancialDocument {
./core/syn2100.go:93:func (t *TradeFinanceToken) AddLiquidity(addr string, amt uint64) {
./core/syn2100.go:100:func (t *TradeFinanceToken) RemoveLiquidity(addr string, amt uint64) error {
./warfare_node.go:21:func NewWarfareNode(id string) *WarfareNode {
./warfare_node.go:26:func (w *WarfareNode) GetID() string { return w.id }
./warfare_node.go:30:func (w *WarfareNode) SecureCommand(cmd string) error {
./warfare_node.go:38:func (w *WarfareNode) TrackLogistics(assetID, location, status string) {
./warfare_node.go:52:func (w *WarfareNode) ShareTactical(info string) {
./warfare_node.go:57:func (w *WarfareNode) Logistics() []militarynodes.LogisticsRecord {
./warfare_node.go:67:func (w *WarfareNode) LogisticsByAsset(assetID string) []militarynodes.LogisticsRecord {
./staking_node.go:15:func NewStakingNode() *StakingNode {
./staking_node.go:20:func (s *StakingNode) Stake(addr string, amt uint64) {
./staking_node.go:28:func (s *StakingNode) Unstake(addr string, amt uint64) {
./staking_node.go:40:func (s *StakingNode) Balance(addr string) uint64 {
./staking_node.go:47:func (s *StakingNode) TotalStaked() uint64 {
./private_transactions.go:13:func Encrypt(key, plaintext []byte) ([]byte, error) {
./private_transactions.go:31:func Decrypt(key, data []byte) ([]byte, error) {
./private_transactions.go:62:func NewPrivateTxManager() *PrivateTxManager {
./private_transactions.go:67:func (m *PrivateTxManager) Send(tx PrivateTransaction) {
./private_transactions.go:74:func (m *PrivateTxManager) List() []PrivateTransaction {
./node_ext/optimization_nodes/optimization.go:25:func (o *SimpleOptimizer) Optimize(m Metrics) Suggestion {
./node_ext/holographic_node.go:17:func NewHolographicNode(id string) *HolographicNode {
./node_ext/holographic_node.go:25:func (n *HolographicNode) ID() string { return n.id }
./node_ext/holographic_node.go:29:func (n *HolographicNode) Start() error { return nil }
./node_ext/holographic_node.go:33:func (n *HolographicNode) Stop() error { return nil }
./node_ext/holographic_node.go:36:func (n *HolographicNode) Store(frame synnergy.HolographicFrame) {
./node_ext/holographic_node.go:44:func (n *HolographicNode) Retrieve(id string) (synnergy.HolographicFrame, bool) {
./mobile_mining_node.go:20:func NewMobileMiningNode(id string, hashRate, battery, threshold float64) *MobileMiningNode {
./mobile_mining_node.go:25:func (m *MobileMiningNode) UpdateBattery(level float64) {
./mobile_mining_node.go:35:func (m *MobileMiningNode) Start() error {
./mobile_mining_node.go:47:func (m *MobileMiningNode) Battery() float64 {
./mobile_mining_node.go:54:func (m *MobileMiningNode) Threshold() float64 {
./mobile_mining_node.go:61:func (m *MobileMiningNode) SetThreshold(th float64) {
./internal/tokens/syn4700.go:44:func NewLegalToken(id, name, symbol, docType, hash, owner string, expiry time.Time, supply uint64, parties []string) *LegalToken {
./internal/tokens/syn4700.go:63:func (t *LegalToken) Sign(party, sig string) error {
./internal/tokens/syn4700.go:74:func (t *LegalToken) RevokeSignature(party string) {
./internal/tokens/syn4700.go:81:func (t *LegalToken) UpdateStatus(status LegalTokenStatus) {
./internal/tokens/syn4700.go:88:func (t *LegalToken) Dispute(action, result string) {
./internal/tokens/syn4700.go:95:func (t *LegalToken) partyExists(party string) bool {
./internal/tokens/syn4700.go:111:func NewLegalTokenRegistry() *LegalTokenRegistry {
./internal/tokens/syn4700.go:116:func (r *LegalTokenRegistry) Add(t *LegalToken) {
./internal/tokens/syn4700.go:123:func (r *LegalTokenRegistry) Get(id string) (*LegalToken, bool) {
./internal/tokens/syn4700.go:131:func (r *LegalTokenRegistry) Remove(id string) {
./internal/tokens/syn4700.go:138:func (r *LegalTokenRegistry) List() []*LegalToken {
./internal/tokens/syn3400.go:27:func NewForexRegistry() *ForexRegistry {
./internal/tokens/syn3400.go:32:func (r *ForexRegistry) Register(base, quote string, rate float64) *ForexPair {
./internal/tokens/syn3400.go:43:func (r *ForexRegistry) UpdateRate(pairID string, rate float64) error {
./internal/tokens/syn3400.go:56:func (r *ForexRegistry) Get(pairID string) (*ForexPair, bool) {
./internal/tokens/syn3400.go:68:func (r *ForexRegistry) List() []*ForexPair {
./internal/tokens/syn2600.go:36:func NewInvestorRegistry() *InvestorRegistry {
./internal/tokens/syn2600.go:41:func (r *InvestorRegistry) Issue(asset, owner string, shares uint64, expiry time.Time) *InvestorTokenMeta {
./internal/tokens/syn2600.go:60:func (r *InvestorRegistry) Transfer(tokenID, newOwner string) error {
./internal/tokens/syn2600.go:72:func (r *InvestorRegistry) RecordReturn(tokenID string, amount uint64) error {
./internal/tokens/syn2600.go:84:func (r *InvestorRegistry) Get(tokenID string) (*InvestorTokenMeta, bool) {
./internal/tokens/syn2600.go:97:func (r *InvestorRegistry) List() []*InvestorTokenMeta {
./internal/tokens/syn200.go:39:func NewCarbonRegistry() *CarbonRegistry {
./internal/tokens/syn200.go:44:func (r *CarbonRegistry) Register(owner, name string, total uint64) *CarbonProject {
./internal/tokens/syn200.go:62:func (r *CarbonRegistry) Issue(projectID, holder string, amount uint64) error {
./internal/tokens/syn200.go:78:func (r *CarbonRegistry) Retire(projectID, holder string, amount uint64) error {
./internal/tokens/syn200.go:96:func (r *CarbonRegistry) AddVerification(projectID, verifier, verID, status string) error {
./internal/tokens/syn200.go:109:func (r *CarbonRegistry) Verifications(projectID string) ([]Verification, bool) {
./internal/tokens/syn200.go:120:func (r *CarbonRegistry) ProjectInfo(projectID string) (*CarbonProject, bool) {
./internal/tokens/syn200.go:137:func (r *CarbonRegistry) ListProjects() []*CarbonProject {
./internal/tokens/syn1000_index.go:12:func NewSYN1000Index() *SYN1000Index {
./internal/tokens/syn1000_index.go:17:func (i *SYN1000Index) Create(name, symbol string, decimals uint8) TokenID {
./internal/tokens/syn1000_index.go:25:func (i *SYN1000Index) Token(id TokenID) (*SYN1000Token, error) {
./internal/tokens/syn1000_index.go:34:func (i *SYN1000Index) AddReserve(id TokenID, asset string, amount float64) error {
./internal/tokens/syn1000_index.go:44:func (i *SYN1000Index) SetReservePrice(id TokenID, asset string, price float64) error {
./internal/tokens/syn1000_index.go:54:func (i *SYN1000Index) TotalValue(id TokenID) (float64, error) {
./core/syn131_token.go:20:func NewSYN131Registry() *SYN131Registry {
./core/syn131_token.go:25:func (r *SYN131Registry) Create(id, name, symbol, owner string, valuation uint64) (*SYN131Token, error) {
./core/syn131_token.go:35:func (r *SYN131Registry) UpdateValuation(id string, val uint64) error {
./core/syn131_token.go:45:func (r *SYN131Registry) Get(id string) (*SYN131Token, bool) {
./internal/tokens/syn845.go:39:func NewDebtRegistry() *DebtRegistry {
./internal/tokens/syn845.go:44:func (r *DebtRegistry) CreateToken(name, symbol, owner string, supply uint64) (string, *DebtToken) {
./internal/tokens/syn845.go:55:func (r *DebtRegistry) IssueDebt(tokenID, debtID, borrower string, principal uint64, rate, penalty float64, due time.Time) error {
./internal/tokens/syn845.go:70:func (r *DebtRegistry) RecordPayment(tokenID, debtID string, amount uint64) error {
./internal/tokens/syn845.go:86:func (r *DebtRegistry) GetDebt(tokenID, debtID string) (*DebtRecord, error) {
./internal/tokens/base.go:36:func NewBaseToken(id TokenID, name, symbol string, decimals uint8) *BaseToken {
./internal/tokens/base.go:48:func (t *BaseToken) ID() TokenID { return t.id }
./internal/tokens/base.go:51:func (t *BaseToken) Name() string { return t.name }
./internal/tokens/base.go:54:func (t *BaseToken) Symbol() string { return t.symbol }
./internal/tokens/base.go:57:func (t *BaseToken) Decimals() uint8 { return t.decimals }
./internal/tokens/base.go:60:func (t *BaseToken) TotalSupply() uint64 { return t.supply }
./internal/tokens/base.go:63:func (t *BaseToken) BalanceOf(addr string) uint64 {
./internal/tokens/base.go:68:func (t *BaseToken) Transfer(from, to string, amount uint64) error {
./internal/tokens/base.go:78:func (t *BaseToken) TransferFrom(owner, spender, to string, amount uint64) error {
./internal/tokens/base.go:92:func (t *BaseToken) Mint(to string, amount uint64) error {
./internal/tokens/base.go:99:func (t *BaseToken) Burn(from string, amount uint64) error {
./internal/tokens/base.go:109:func (t *BaseToken) Approve(owner, spender string, amount uint64) error {
./internal/tokens/base.go:118:func (t *BaseToken) Allowance(owner, spender string) uint64 {
./core/staking_node.go:12:func NewStakingNode() *StakingNode {
./core/staking_node.go:17:func (s *StakingNode) Stake(addr string, amt uint64) {
./core/staking_node.go:25:func (s *StakingNode) Unstake(addr string, amt uint64) {
./core/staking_node.go:37:func (s *StakingNode) Balance(addr string) uint64 {
./core/staking_node.go:44:func (s *StakingNode) TotalStaked() uint64 {
./internal/p2p/discovery.go:10:func NewDiscoveryService(m *Manager, bootstrap []Peer) *DiscoveryService {
./internal/p2p/discovery.go:15:func (d *DiscoveryService) DiscoverPeers() []Peer {
./internal/tokens/syn3700_token.go:23:func NewSYN3700Token(name, symbol string) *SYN3700Token {
./internal/tokens/syn3700_token.go:28:func (t *SYN3700Token) AddComponent(token string, weight float64) {
./internal/tokens/syn3700_token.go:35:func (t *SYN3700Token) RemoveComponent(token string) error {
./internal/tokens/syn3700_token.go:48:func (t *SYN3700Token) ListComponents() []IndexComponent {
./internal/tokens/syn3700_token.go:57:func (t *SYN3700Token) Value(prices map[string]float64) float64 {
./internal/tokens/syn2900.go:42:func NewInsuranceRegistry() *InsuranceRegistry {
./internal/tokens/syn2900.go:47:func (r *InsuranceRegistry) IssuePolicy(holder, coverage string, premium, payout, deductible, limit uint64, start, end time.Time) *InsurancePolicy {
./internal/tokens/syn2900.go:69:func (r *InsuranceRegistry) FileClaim(policyID, desc string, amount uint64) (*ClaimRecord, error) {
./internal/tokens/syn2900.go:84:func (r *InsuranceRegistry) GetPolicy(policyID string) (*InsurancePolicy, bool) {
./internal/tokens/syn2900.go:97:func (r *InsuranceRegistry) ListPolicies() []*InsurancePolicy {
./core/sidechains.go:25:func NewSidechainRegistry() *SidechainRegistry {
./core/sidechains.go:30:func (r *SidechainRegistry) Register(id, meta string, validators []string) (*Sidechain, error) {
./core/sidechains.go:42:func (r *SidechainRegistry) SubmitHeader(id, header string) error {
./core/sidechains.go:54:func (r *SidechainRegistry) GetHeader(id string) (string, bool) {
./core/sidechains.go:65:func (r *SidechainRegistry) Meta(id string) (Sidechain, bool) {
./core/sidechains.go:76:func (r *SidechainRegistry) List() []Sidechain {
./core/sidechains.go:87:func (r *SidechainRegistry) Pause(id string) error {
./core/sidechains.go:99:func (r *SidechainRegistry) Resume(id string) error {
./core/sidechains.go:111:func (r *SidechainRegistry) UpdateValidators(id string, validators []string) error {
./core/sidechains.go:123:func (r *SidechainRegistry) Remove(id string) error {
./internal/tokens/syn2369.go:28:func NewItemRegistry() *ItemRegistry {
./internal/tokens/syn2369.go:33:func (r *ItemRegistry) CreateItem(owner, name, desc string, attrs map[string]string) *VirtualItem {
./internal/tokens/syn2369.go:47:func (r *ItemRegistry) TransferItem(itemID, newOwner string) error {
./internal/tokens/syn2369.go:59:func (r *ItemRegistry) UpdateAttributes(itemID string, attrs map[string]string) error {
./internal/tokens/syn2369.go:73:func (r *ItemRegistry) GetItem(itemID string) (*VirtualItem, bool) {
./internal/tokens/syn2369.go:89:func (r *ItemRegistry) ListItems() []*VirtualItem {
./internal/tokens/syn12.go:22:func NewSYN12Token(id TokenID, name, symbol string, meta SYN12Metadata, decimals uint8) *SYN12Token {
./internal/nodes/holographic_node.go:18:func NewHolographicNode(id Address) *HolographicNode {
./internal/nodes/holographic_node.go:27:func (n *HolographicNode) ID() Address { return n.id }
./internal/nodes/holographic_node.go:31:func (n *HolographicNode) Start() error { return nil }
./internal/nodes/holographic_node.go:35:func (n *HolographicNode) Stop() error { return nil }
./internal/nodes/holographic_node.go:38:func (n *HolographicNode) Peers() []Address {
./internal/nodes/holographic_node.go:49:func (n *HolographicNode) DialSeed(addr Address) error {
./internal/nodes/holographic_node.go:57:func (n *HolographicNode) Store(frame synnergy.HolographicFrame) {
./internal/nodes/holographic_node.go:65:func (n *HolographicNode) Retrieve(id string) (synnergy.HolographicFrame, bool) {
./internal/tokens/syn10.go:11:func NewSYN10Token(id TokenID, name, symbol, issuer string, rate float64, decimals uint8) *SYN10Token {
./internal/tokens/syn10.go:20:func (t *SYN10Token) SetExchangeRate(rate float64) {
./internal/tokens/syn10.go:34:func (t *SYN10Token) Info() SYN10Info {
./internal/p2p/peer.go:19:func NewManager() *Manager {
./internal/p2p/peer.go:24:func (m *Manager) AddPeer(p Peer) {
./internal/p2p/peer.go:31:func (m *Manager) RemovePeer(id string) {
./internal/p2p/peer.go:38:func (m *Manager) GetPeer(id string) (Peer, bool) {
./internal/p2p/peer.go:46:func (m *Manager) ListPeers() []Peer {
./core/rollups.go:25:func NewRollupAggregator() *RollupAggregator {
./core/rollups.go:30:func (a *RollupAggregator) SubmitBatch(txs []string) (string, error) {
./core/rollups.go:43:func (a *RollupAggregator) ChallengeBatch(id string, txIdx int, proof []byte) error {
./core/rollups.go:59:func (a *RollupAggregator) FinalizeBatch(id string, valid bool) error {
./core/rollups.go:75:func (a *RollupAggregator) BatchInfo(id string) (RollupBatch, bool) {
./core/rollups.go:86:func (a *RollupAggregator) ListBatches() []RollupBatch {
./core/rollups.go:97:func (a *RollupAggregator) BatchTransactions(id string) ([]string, error) {
./core/rollups.go:108:func (a *RollupAggregator) Pause() {
./core/rollups.go:115:func (a *RollupAggregator) Resume() {
./core/rollups.go:122:func (a *RollupAggregator) Status() bool {
./core/regulatory_management.go:23:func NewRegulatoryManager() *RegulatoryManager {
./core/regulatory_management.go:28:func (m *RegulatoryManager) AddRegulation(reg Regulation) error {
./core/regulatory_management.go:39:func (m *RegulatoryManager) RemoveRegulation(id string) {
./core/regulatory_management.go:46:func (m *RegulatoryManager) GetRegulation(id string) (Regulation, bool) {
./core/regulatory_management.go:54:func (m *RegulatoryManager) ListRegulations() []Regulation {
./core/regulatory_management.go:65:func (m *RegulatoryManager) EvaluateTransaction(tx Transaction) []string {
./indexing_node.go:13:func NewIndexingNode() *IndexingNode {
./indexing_node.go:18:func (n *IndexingNode) Index(key string, value []byte) {
./indexing_node.go:26:func (n *IndexingNode) Query(key string) ([]byte, bool) {
./indexing_node.go:39:func (n *IndexingNode) Remove(key string) {
./indexing_node.go:46:func (n *IndexingNode) Keys() []string {
./indexing_node.go:57:func (n *IndexingNode) Count() int {
./internal/nodes/elected_authority_node.go:16:func NewElectedAuthorityNode(addr Address, role string, term time.Duration) *ElectedAuthorityNode {
./internal/nodes/elected_authority_node.go:22:func (n *ElectedAuthorityNode) IsActive(now time.Time) bool {
./core/plasma_management.go:4:func (b *PlasmaBridge) Pause() {
./core/plasma_management.go:11:func (b *PlasmaBridge) Resume() {
./core/plasma_management.go:18:func (b *PlasmaBridge) Status() bool {
./high_availability.go:20:func NewFailoverManager(primary string, timeout time.Duration) *FailoverManager {
./high_availability.go:29:func (m *FailoverManager) RegisterBackup(id string) {
./high_availability.go:36:func (m *FailoverManager) Heartbeat(id string) {
./high_availability.go:45:func (m *FailoverManager) Active() string {
./faucet.go:21:func NewFaucet(balance, amount uint64, cooldown time.Duration) *Faucet {
./faucet.go:27:func (f *Faucet) Request(addr string, now time.Time) (uint64, error) {
./faucet.go:42:func (f *Faucet) Balance() uint64 {
./faucet.go:49:func (f *Faucet) Configure(amount uint64, cooldown time.Duration) {
./core/node_adapter.go:12:func NewNodeAdapter(n *Node) *NodeAdapter {
./internal/auth/rbac.go:25:func NewRBAC() *RBAC {
./internal/auth/rbac.go:33:func (r *RBAC) AddRole(name string) {
./internal/auth/rbac.go:43:func (r *RBAC) AddPermissionToRole(roleName string, perm Permission) error {
./internal/auth/rbac.go:55:func (r *RBAC) AssignRole(userID, roleName string) error {
./internal/auth/rbac.go:69:func (r *RBAC) hasPermission(userID string, perm Permission) bool {
./internal/auth/rbac.go:95:func NewPolicyEnforcer(r *RBAC, l AuditLogger) *PolicyEnforcer {
./internal/auth/rbac.go:100:func (p *PolicyEnforcer) Authorize(userID string, perm Permission, metadata map[string]any) error {
./dynamic_consensus_hopping.go:32:func NewConsensusHopper(initial ConsensusMode) *ConsensusHopper {
./dynamic_consensus_hopping.go:37:func (h *ConsensusHopper) Mode() ConsensusMode {
./dynamic_consensus_hopping.go:44:func (h *ConsensusHopper) SetMode(m ConsensusMode) {
./dynamic_consensus_hopping.go:51:func (h *ConsensusHopper) LastMetrics() NetworkMetrics {
./dynamic_consensus_hopping.go:58:func (h *ConsensusHopper) Evaluate(m NetworkMetrics) ConsensusMode {
./identity_verification.go:30:func NewIdentityService() *IdentityService {
./identity_verification.go:38:func (s *IdentityService) Register(addr, name, dob, nationality string) error {
./identity_verification.go:49:func (s *IdentityService) Verify(addr, method string) error {
./identity_verification.go:61:func (s *IdentityService) Info(addr string) (IdentityInfo, bool) {
./identity_verification.go:69:func (s *IdentityService) Logs(addr string) []VerificationLog {
./core/mobile_mining_node.go:13:func NewMobileMiningNode(hashRate, powerLimit uint64) *MobileMiningNode {
./core/mobile_mining_node.go:18:func (mm *MobileMiningNode) Start() {
./core/mobile_mining_node.go:25:func (mm *MobileMiningNode) Stop() { mm.base.Stop() }
./core/mobile_mining_node.go:28:func (mm *MobileMiningNode) IsMining() bool { return mm.base.IsMining() }
./core/mobile_mining_node.go:31:func (mm *MobileMiningNode) Mine(data []byte) (string, error) {
./core/mobile_mining_node.go:41:func (mm *MobileMiningNode) SetPowerLimit(limit uint64) {
./core/mobile_mining_node.go:48:func (mm *MobileMiningNode) PowerLimit() uint64 {
./gas_table.go:24:func LoadGasTable() GasTable {
./gas_table.go:55:func GasCost(opcode string) uint64 {
./core/loanpool_management.go:17:func NewLoanPoolManager(p *LoanPool) *LoanPoolManager {
./core/loanpool_management.go:22:func (m *LoanPoolManager) Pause() {
./core/loanpool_management.go:27:func (m *LoanPoolManager) Resume() {
./core/loanpool_management.go:32:func (m *LoanPoolManager) Stats() LoanPoolStats {
./cross_chain_bridge.go:31:func NewBridgeTransferManager() *BridgeTransferManager {
./cross_chain_bridge.go:36:func (m *BridgeTransferManager) Deposit(bridgeID, from, to string, amount uint64, tokenID string) string {
./cross_chain_bridge.go:53:func (m *BridgeTransferManager) Claim(id string, proof []byte) error {
./cross_chain_bridge.go:70:func (m *BridgeTransferManager) GetTransfer(id string) (*BridgeTransfer, bool) {
./cross_chain_bridge.go:78:func (m *BridgeTransferManager) ListTransfers() []*BridgeTransfer {
./core/liquidity_pools.go:21:func NewLiquidityPool(id, tokenA, tokenB string, feeBps uint16) *LiquidityPool {
./core/liquidity_pools.go:32:func (p *LiquidityPool) AddLiquidity(provider string, amtA, amtB uint64) (uint64, error) {
./core/liquidity_pools.go:57:func (p *LiquidityPool) RemoveLiquidity(provider string, lpTokens uint64) (uint64, uint64, error) {
./core/liquidity_pools.go:72:func (p *LiquidityPool) Swap(tokenIn string, amtIn, minOut uint64) (uint64, error) {
./core/liquidity_pools.go:102:func sqrt(n uint64) uint64 {
./core/liquidity_pools.go:117:func NewLiquidityPoolRegistry() *LiquidityPoolRegistry {
./core/liquidity_pools.go:122:func (r *LiquidityPoolRegistry) Create(id, tokenA, tokenB string, feeBps uint16) (*LiquidityPool, error) {
./core/liquidity_pools.go:132:func (r *LiquidityPoolRegistry) Get(id string) (*LiquidityPool, bool) {
./core/liquidity_pools.go:138:func (r *LiquidityPoolRegistry) List() []*LiquidityPool {
./energy_efficient_node.go:26:func NewEnergyEfficientNode(id string, tracker *EnergyEfficiencyTracker) *EnergyEfficientNode {
./energy_efficient_node.go:31:func (n *EnergyEfficientNode) ID() string { return n.id }
./energy_efficient_node.go:34:func (n *EnergyEfficientNode) RecordUsage(txProcessed int, energyKWh float64) {
./energy_efficient_node.go:39:func (n *EnergyEfficientNode) AddOffset(credits float64) {
./energy_efficient_node.go:46:func (n *EnergyEfficientNode) OffsetCredits() float64 {
./energy_efficient_node.go:53:func (n *EnergyEfficientNode) Certify() SustainabilityCertificate {
./energy_efficient_node.go:68:func (n *EnergyEfficientNode) Certificate() SustainabilityCertificate {
./energy_efficient_node.go:75:func (n *EnergyEfficientNode) ShouldThrottle(threshold float64) bool {
./core/watchtower_node.go:27:func NewWatchtowerNode(id string, logger *log.Logger) *Watchtower {
./core/watchtower_node.go:37:func (w *Watchtower) ID() string { return w.id }
./core/watchtower_node.go:40:func (w *Watchtower) Start(ctx context.Context) error {
./core/watchtower_node.go:54:func (w *Watchtower) monitorLoop(ctx context.Context) {
./core/watchtower_node.go:71:func (w *Watchtower) Stop() error {
./core/watchtower_node.go:83:func (w *Watchtower) ReportFork(height uint64, hash string) {
./core/watchtower_node.go:90:func (w *Watchtower) Metrics() watchtower.Metrics {
./core/watchtower_node.go:95:func (w *Watchtower) Firewall() *Firewall { return w.firewall }
./data_operations.go:19:func NewDataFeed(id string) *DataFeed {
./data_operations.go:24:func (f *DataFeed) Update(key, value string) {
./data_operations.go:32:func (f *DataFeed) Get(key string) (string, bool) {
./data_operations.go:40:func (f *DataFeed) Delete(key string) {
./data_operations.go:50:func (f *DataFeed) Keys() []string {
./data_operations.go:61:func (f *DataFeed) Snapshot() map[string]string {
./data_operations.go:72:func (f *DataFeed) LastUpdated() time.Time {
./cross_chain_contracts.go:19:func NewXContractRegistry() *XContractRegistry {
./cross_chain_contracts.go:24:func (r *XContractRegistry) RegisterMapping(localAddr, remoteChain, remoteAddr string) {
./cross_chain_contracts.go:35:func (r *XContractRegistry) ListMappings() []XContractMapping {
./cross_chain_contracts.go:46:func (r *XContractRegistry) GetMapping(localAddr string) (XContractMapping, bool) {
./cross_chain_contracts.go:54:func (r *XContractRegistry) RemoveMapping(localAddr string) {
./core/identity_verification.go:30:func NewIdentityService() *IdentityService {
./core/identity_verification.go:38:func (s *IdentityService) Register(addr, name, dob, nationality string) error {
./core/identity_verification.go:49:func (s *IdentityService) Verify(addr, method string) error {
./core/identity_verification.go:61:func (s *IdentityService) Info(addr string) (IdentityInfo, bool) {
./core/identity_verification.go:69:func (s *IdentityService) Logs(addr string) []VerificationLog {
./core/virtual_machine.go:42:func (vm *SimpleVM) Call(string) error { return nil }
./core/virtual_machine.go:46:func (vm *SimpleVM) Gas(uint64) error { return nil }
./core/virtual_machine.go:51:func NewSimpleVM(modes ...VMMode) *SimpleVM {
./core/virtual_machine.go:84:func (vm *SimpleVM) Start() error {
./core/virtual_machine.go:95:func (vm *SimpleVM) Stop() error {
./core/virtual_machine.go:106:func (vm *SimpleVM) Status() bool {
./core/virtual_machine.go:115:func (vm *SimpleVM) Execute(wasm []byte, method string, args []byte, gasLimit uint64) ([]byte, uint64, error) {
./core/genesis_wallets.go:22:func hashAddress(label string) string {
./core/genesis_wallets.go:28:func DefaultGenesisWallets() GenesisWallets {
./core/genesis_wallets.go:44:func AllocateToGenesisWallets(total uint64, wallets GenesisWallets) map[string]uint64 {
./cross_chain.go:26:func NewCrossChainManager() *CrossChainManager {
./cross_chain.go:34:func (m *CrossChainManager) RegisterBridge(sourceChain, targetChain, relayerAddr string) string {
./cross_chain.go:52:func (m *CrossChainManager) ListBridges() []*Bridge {
./cross_chain.go:63:func (m *CrossChainManager) GetBridge(id string) (*Bridge, bool) {
./cross_chain.go:71:func (m *CrossChainManager) AuthorizeRelayer(addr string) {
./cross_chain.go:78:func (m *CrossChainManager) RevokeRelayer(addr string) {
./cross_chain.go:85:func (m *CrossChainManager) IsRelayerAuthorized(addr string) bool {
./core/token_syn4900.go:34:func NewAgriculturalRegistry() *AgriculturalRegistry {
./core/token_syn4900.go:39:func (r *AgriculturalRegistry) Register(id, assetType, owner, origin string, qty uint64, harvest, expiry time.Time, cert string) (*AgriculturalAsset, error) {
./core/token_syn4900.go:49:func (r *AgriculturalRegistry) Transfer(id, newOwner string) error {
./core/token_syn4900.go:60:func (r *AgriculturalRegistry) UpdateStatus(id, status string) error {
./core/token_syn4900.go:71:func (r *AgriculturalRegistry) Get(id string) (*AgriculturalAsset, bool) {
./core/full_node.go:22:func NewFullNode(id nodes.Address, mode FullNodeMode) *FullNode {
./core/full_node.go:27:func (f *FullNode) SetMode(m FullNodeMode) {
./core/full_node.go:32:func (f *FullNode) CurrentMode() FullNodeMode {
./core/full_node.go:37:func (f *FullNode) IsArchive() bool {
./core/syn700.go:42:func NewIPRegistry() *IPRegistry {
./core/syn700.go:47:func (r *IPRegistry) Register(tokenID, title, desc, creator, owner string) (*IPTokens, error) {
./core/syn700.go:57:func (r *IPRegistry) CreateLicense(tokenID, licID, licType, licensee string, royalty uint64) error {
./core/syn700.go:70:func (r *IPRegistry) RecordRoyalty(tokenID, licID, licensee string, amount uint64) error {
./core/syn700.go:83:func (r *IPRegistry) Get(tokenID string) (*IPTokens, bool) {
./core/wallet.go:19:func NewWallet() (*Wallet, error) {
./core/wallet.go:32:func (w *Wallet) Sign(tx *Transaction) ([]byte, error) {
./core/wallet.go:48:func VerifySignature(tx *Transaction, sig []byte, pub *ecdsa.PublicKey) bool {
./core/faucet.go:19:func NewFaucet(balance, amount uint64, cooldown time.Duration) *Faucet {
./core/faucet.go:29:func (f *Faucet) Request(addr string) (uint64, error) {
./core/faucet.go:45:func (f *Faucet) Balance() uint64 {
./core/faucet.go:52:func (f *Faucet) UpdateConfig(amount uint64, cooldown time.Duration) {
./core/syn4700.go:44:func NewLegalToken(id, name, symbol, docType, hash, owner string, expiry time.Time, supply uint64, parties []string) *LegalToken {
./core/syn4700.go:63:func (t *LegalToken) Sign(party, sig string) error {
./core/syn4700.go:74:func (t *LegalToken) RevokeSignature(party string) {
./core/syn4700.go:81:func (t *LegalToken) UpdateStatus(status LegalTokenStatus) {
./core/syn4700.go:88:func (t *LegalToken) Dispute(action, result string) {
./core/syn4700.go:95:func (t *LegalToken) partyExists(party string) bool {
./core/syn4700.go:111:func NewLegalTokenRegistry() *LegalTokenRegistry {
./core/syn4700.go:116:func (r *LegalTokenRegistry) Add(t *LegalToken) {
./core/syn4700.go:123:func (r *LegalTokenRegistry) Get(id string) (*LegalToken, bool) {
./core/syn4700.go:131:func (r *LegalTokenRegistry) Remove(id string) {
./core/syn4700.go:138:func (r *LegalTokenRegistry) List() []*LegalToken {
./core/dao_quadratic_voting.go:6:func QuadraticWeight(tokens uint64) uint64 {
./core/dao_quadratic_voting.go:11:func (pm *ProposalManager) CastQuadraticVote(id, voter string, tokens uint64, support bool) error {
./core/transaction_control.go:24:func ScheduleTransaction(tx *Transaction, exec time.Time) *ScheduledTransaction {
./core/transaction_control.go:30:func CancelTransaction(st *ScheduledTransaction) bool {
./core/transaction_control.go:40:func ReverseTransaction(l *Ledger, tx *Transaction) error {
./core/transaction_control.go:53:func ConvertToPrivate(tx *Transaction, key []byte) (*PrivateTransaction, error) {
./core/transaction_control.go:76:func (pt *PrivateTransaction) Decrypt(key []byte) (*Transaction, error) {
./core/transaction_control.go:105:func GenerateReceipt(txID, status, details string) Receipt {
./core/transaction_control.go:116:func NewReceiptStore() *ReceiptStore {
./core/transaction_control.go:121:func (rs *ReceiptStore) Store(r Receipt) {
./core/transaction_control.go:128:func (rs *ReceiptStore) Get(id string) (Receipt, bool) {
./core/transaction_control.go:136:func (rs *ReceiptStore) Search(keyword string) []Receipt {
./core/syn3700_token.go:23:func NewSYN3700Token(name, symbol string) *SYN3700Token {
./core/syn3700_token.go:28:func (t *SYN3700Token) AddComponent(token string, weight float64) {
./core/syn3700_token.go:35:func (t *SYN3700Token) RemoveComponent(token string) error {
./core/syn3700_token.go:48:func (t *SYN3700Token) ListComponents() []IndexComponent {
./core/syn3700_token.go:57:func (t *SYN3700Token) Value(prices map[string]float64) float64 {
./core/system_health_logging.go:19:func NewSystemHealthLogger() *SystemHealthLogger {
./core/system_health_logging.go:25:func (l *SystemHealthLogger) Collect(peerCount int, height uint64) watchtower.Metrics {
./core/system_health_logging.go:44:func (l *SystemHealthLogger) Snapshot() watchtower.Metrics {
./core/custodial_node.go:10:func NewCustodialNode(id, addr string, ledger *Ledger) *CustodialNode {
./core/custodial_node.go:18:func (n *CustodialNode) Custody(user string, amount uint64) {
./core/custodial_node.go:23:func (n *CustodialNode) Release(user string, amount uint64) bool {
./core/syn5000.go:31:func NewSYN5000Token(name, symbol string, decimals uint8) *SYN5000Token {
./core/syn5000.go:36:func (t *SYN5000Token) PlaceBet(bettor string, amount uint64, odds float64, game string) uint64 {
./core/syn5000.go:46:func (t *SYN5000Token) ResolveBet(betID uint64, win bool) (uint64, error) {
./core/syn5000.go:65:func (t *SYN5000Token) GetBet(betID uint64) (*BetRecord, bool) {
./core/syn300_token.go:30:func NewSYN300Token(initial map[string]uint64) *SYN300Token {
./core/syn300_token.go:44:func (t *SYN300Token) Delegate(owner, delegate string) {
./core/syn300_token.go:55:func (t *SYN300Token) RevokeDelegation(owner string) {
./core/syn300_token.go:62:func (t *SYN300Token) VotingPower(addr string) uint64 {
./core/syn300_token.go:68:func (t *SYN300Token) votingPowerLocked(addr string) uint64 {
./core/syn300_token.go:79:func (t *SYN300Token) CreateProposal(creator, description string) uint64 {
./core/syn300_token.go:96:func (t *SYN300Token) Vote(id uint64, voter string, approve bool) error {
./core/syn300_token.go:117:func (t *SYN300Token) Execute(id uint64, quorum uint64) error {
./core/syn300_token.go:139:func (t *SYN300Token) ProposalStatus(id uint64) (*GovernanceProposal, error) {
./core/syn300_token.go:160:func (t *SYN300Token) ListProposals() []*GovernanceProposal {
./core/cross_chain_connection.go:24:func NewChainConnectionManager() *ChainConnectionManager {
./core/cross_chain_connection.go:29:func (m *ChainConnectionManager) Open(local, remote string) int {
./core/cross_chain_connection.go:39:func (m *ChainConnectionManager) Close(id int) error {
./core/cross_chain_connection.go:51:func (m *ChainConnectionManager) Get(id int) (*ChainConnection, error) {
./core/cross_chain_connection.go:62:func (m *ChainConnectionManager) List() []*ChainConnection {
./core/syn3900.go:25:func NewBenefitRegistry() *BenefitRegistry {
./core/syn3900.go:30:func (r *BenefitRegistry) RegisterBenefit(recipient, program string, amount uint64) uint64 {
./core/syn3900.go:40:func (r *BenefitRegistry) Claim(id uint64) error {
./core/syn3900.go:55:func (r *BenefitRegistry) GetBenefit(id uint64) (*BenefitRecord, bool) {
./core/syn223_token.go:20:func NewSYN223Token(name, symbol, owner string, supply uint64) *SYN223Token {
./core/syn223_token.go:34:func (t *SYN223Token) AddToWhitelist(addr string) {
./core/syn223_token.go:41:func (t *SYN223Token) RemoveFromWhitelist(addr string) {
./core/syn223_token.go:48:func (t *SYN223Token) AddToBlacklist(addr string) {
./core/syn223_token.go:55:func (t *SYN223Token) RemoveFromBlacklist(addr string) {
./core/syn223_token.go:62:func (t *SYN223Token) Transfer(from, to string, amount uint64) error {
./core/syn223_token.go:82:func (t *SYN223Token) BalanceOf(addr string) uint64 {
./watchtower_node.go:27:func NewWatchtowerNode(id string, logger *log.Logger) *WatchtowerNode {
./watchtower_node.go:37:func (w *WatchtowerNode) ID() string { return w.id }
./watchtower_node.go:40:func (w *WatchtowerNode) Start(ctx context.Context) error {
./watchtower_node.go:54:func (w *WatchtowerNode) monitorLoop(ctx context.Context) {
./watchtower_node.go:71:func (w *WatchtowerNode) Stop() error {
./watchtower_node.go:83:func (w *WatchtowerNode) ReportFork(height uint64, hash string) {
./watchtower_node.go:90:func (w *WatchtowerNode) Metrics() watchtower.Metrics {
./watchtower_node.go:95:func (w *WatchtowerNode) Firewall() *Firewall { return w.firewall }
./core/contracts_opcodes.go:22:func opcodeByName(name string) Opcode {
./core/consensus_start.go:16:func NewConsensusService(n *Node) *ConsensusService {
./core/consensus_start.go:22:func (s *ConsensusService) Start(interval time.Duration) {
./core/consensus_start.go:41:func (s *ConsensusService) Stop() {
./core/consensus_start.go:49:func (s *ConsensusService) Info() (height int, running bool) {
./core/consensus_adaptive_management.go:12:func NewAdaptiveManager(engine *SynnergyConsensus) *AdaptiveManager {
./core/consensus_adaptive_management.go:18:func (am *AdaptiveManager) Adjust(demand, stake float64) ConsensusWeights {
./core/consensus_adaptive_management.go:30:func (am *AdaptiveManager) Threshold(demand, stake float64) float64 {
./core/consensus_adaptive_management.go:40:func (am *AdaptiveManager) Weights() ConsensusWeights {
./system_health_logging.go:19:func NewSystemHealthLogger() *SystemHealthLogger {
./system_health_logging.go:25:func (l *SystemHealthLogger) Collect(peerCount int, height uint64) watchtower.Metrics {
./system_health_logging.go:44:func (l *SystemHealthLogger) Snapshot() watchtower.Metrics {
./core/syn3500_token.go:19:func NewSYN3500Token(name, symbol, issuer string, rate float64) *SYN3500Token {
./core/syn3500_token.go:30:func (t *SYN3500Token) SetRate(rate float64) {
./core/syn3500_token.go:37:func (t *SYN3500Token) Info() (string, string, float64) {
./core/syn3500_token.go:44:func (t *SYN3500Token) Mint(to string, amt uint64) {
./core/syn3500_token.go:51:func (t *SYN3500Token) Redeem(from string, amt uint64) error {
./core/syn3500_token.go:63:func (t *SYN3500Token) BalanceOf(addr string) uint64 {
./core/compliance.go:44:func NewComplianceService() *ComplianceService {
./core/compliance.go:54:func (s *ComplianceService) ValidateKYC(address string, kycData []byte) (string, error) {
./core/compliance.go:68:func (s *ComplianceService) EraseKYC(address string) {
./core/compliance.go:76:func (s *ComplianceService) RecordFraud(address string, severity int) {
./core/compliance.go:87:func (s *ComplianceService) RiskScore(address string) int {
./core/compliance.go:95:func (s *ComplianceService) AuditTrail(address string) []AuditEntry {
./core/compliance.go:107:func (s *ComplianceService) MonitorTransaction(tx ComplianceTransaction, threshold float64) bool {
./core/compliance.go:119:func (s *ComplianceService) VerifyZKP(blob []byte, commitmentHex, proofHex string) bool {
./core/compliance.go:124:func (s *ComplianceService) appendAudit(addr, event string, metadata map[string]string) {
./core/syn2700.go:18:func NewVestingSchedule(entries []VestingEntry) *VestingSchedule {
./core/syn2700.go:23:func (v *VestingSchedule) Claim(now time.Time) uint64 {
./core/syn2700.go:36:func (v *VestingSchedule) Pending(now time.Time) uint64 {
./regulatory_management.go:23:func NewRegulatoryManager() *RegulatoryManager {
./regulatory_management.go:28:func (m *RegulatoryManager) AddRegulation(reg Regulation) error {
./regulatory_management.go:39:func (m *RegulatoryManager) RemoveRegulation(id string) {
./regulatory_management.go:46:func (m *RegulatoryManager) GetRegulation(id string) (Regulation, bool) {
./regulatory_management.go:54:func (m *RegulatoryManager) ListRegulations() []Regulation {
./regulatory_management.go:65:func (m *RegulatoryManager) EvaluateTransaction(tx Transaction) []string {
./core/blockchain_synchronization.go:16:func NewSyncManager(l *Ledger) *SyncManager {
./core/blockchain_synchronization.go:21:func (s *SyncManager) Start() {
./core/blockchain_synchronization.go:28:func (s *SyncManager) Stop() {
./core/blockchain_synchronization.go:35:func (s *SyncManager) Status() (bool, int) {
./core/blockchain_synchronization.go:42:func (s *SyncManager) Once() error {
./core/syn1401.go:25:func NewInvestmentRegistry() *InvestmentRegistry {
./core/syn1401.go:30:func (r *InvestmentRegistry) Issue(id, owner string, principal uint64, rate float64, maturity time.Time) (*InvestmentRecord, error) {
./core/syn1401.go:40:func (r *InvestmentRegistry) Accrue(id string, now time.Time) (uint64, error) {
./core/syn1401.go:57:func (r *InvestmentRegistry) Redeem(id, to string, now time.Time) (uint64, error) {
./core/syn1401.go:77:func (r *InvestmentRegistry) Get(id string) (*InvestmentRecord, bool) {
./core/biometric_security_node.go:14:func NewBiometricSecurityNode(base *Node, auth *BiometricsAuth) *BiometricSecurityNode {
./core/biometric_security_node.go:22:func (b *BiometricSecurityNode) GetID() string {
./core/biometric_security_node.go:30:func (b *BiometricSecurityNode) Enroll(addr string, biometric []byte) {
./core/biometric_security_node.go:35:func (b *BiometricSecurityNode) Remove(addr string) {
./core/biometric_security_node.go:40:func (b *BiometricSecurityNode) Authenticate(addr string, biometric []byte) bool {
./core/biometric_security_node.go:46:func (b *BiometricSecurityNode) SecureAddTransaction(addr string, biometric []byte, tx *Transaction) error {
./core/biometric_security_node.go:56:func (b *BiometricSecurityNode) SecureExecute(addr string, biometric []byte, fn func() error) error {
./internal/tokens/syn70.go:22:func NewSYN70Token(id TokenID, name, symbol string, decimals uint8) *SYN70Token {
./internal/tokens/syn70.go:30:func (t *SYN70Token) RegisterAsset(id, owner, name, game string) error {
./internal/tokens/syn70.go:39:func (t *SYN70Token) TransferAsset(id, newOwner string) error {
./internal/tokens/syn70.go:52:func (t *SYN70Token) SetAttribute(id, key, value string) error {
./internal/tokens/syn70.go:62:func (t *SYN70Token) AddAchievement(id, name string) error {
./internal/tokens/syn70.go:72:func (t *SYN70Token) AssetInfo(id string) (SYN70Asset, error) {
./internal/tokens/syn70.go:81:func (t *SYN70Token) ListAssets() []SYN70Asset {
./core/bank_institutional_node.go:10:func NewBankInstitutionalNode(id, addr string, ledger *Ledger) *BankInstitutionalNode {
./core/bank_institutional_node.go:18:func (n *BankInstitutionalNode) RegisterInstitution(name string) {
./core/bank_institutional_node.go:23:func (n *BankInstitutionalNode) IsRegistered(name string) bool {
./core/syn1700_token.go:32:func NewEvent(name, desc, location string, start, end int64, supply uint64) *EventMetadata {
./core/syn1700_token.go:45:func (e *EventMetadata) IssueTicket(owner, class, ticketType string, price uint64) (uint64, error) {
./core/syn1700_token.go:58:func (e *EventMetadata) TransferTicket(id uint64, from, to string) error {
./core/syn1700_token.go:70:func (e *EventMetadata) VerifyTicket(id uint64, holder string) bool {
./internal/tokens/syn3500_token.go:19:func NewSYN3500Token(name, symbol, issuer string, rate float64) *SYN3500Token {
./internal/tokens/syn3500_token.go:30:func (t *SYN3500Token) SetRate(rate float64) {
./internal/tokens/syn3500_token.go:37:func (t *SYN3500Token) Info() (string, string, float64) {
./internal/tokens/syn3500_token.go:44:func (t *SYN3500Token) Mint(to string, amt uint64) {
./internal/tokens/syn3500_token.go:51:func (t *SYN3500Token) Redeem(from string, amt uint64) error {
./internal/tokens/syn3500_token.go:63:func (t *SYN3500Token) BalanceOf(addr string) uint64 {
./core/snvm.go:13:func NewSNVM() *SNVM { return &SNVM{} }
./core/snvm.go:19:func (vm *SNVM) Execute(tx *Transaction) (int64, error) {
./internal/tokens/syn2800.go:40:func NewLifePolicyRegistry() *LifePolicyRegistry {
./internal/tokens/syn2800.go:45:func (r *LifePolicyRegistry) IssuePolicy(insured, beneficiary string, coverage, premium uint64, start, end time.Time) *LifePolicy {
./internal/tokens/syn2800.go:65:func (r *LifePolicyRegistry) PayPremium(policyID string, amount uint64) error {
./internal/tokens/syn2800.go:77:func (r *LifePolicyRegistry) FileClaim(policyID string, amount uint64) (*Claim, error) {
./internal/tokens/syn2800.go:92:func (r *LifePolicyRegistry) GetPolicy(policyID string) (*LifePolicy, bool) {
./internal/tokens/syn2800.go:105:func (r *LifePolicyRegistry) ListPolicies() []*LifePolicy {
./core/audit_node.go:20:func NewAuditNode(b BootstrapNode, m *AuditManager) *AuditNode {
./core/audit_node.go:25:func (n *AuditNode) Start() error {
./core/audit_node.go:33:func (n *AuditNode) LogEvent(address, event string, metadata map[string]string) error {
./core/audit_node.go:41:func (n *AuditNode) ListEvents(address string) []AuditEntry {
./internal/tokens/syn223_token.go:20:func NewSYN223Token(name, symbol, owner string, supply uint64) *SYN223Token {
./internal/tokens/syn223_token.go:34:func (t *SYN223Token) AddToWhitelist(addr string) {
./internal/tokens/syn223_token.go:41:func (t *SYN223Token) RemoveFromWhitelist(addr string) {
./internal/tokens/syn223_token.go:48:func (t *SYN223Token) AddToBlacklist(addr string) {
./internal/tokens/syn223_token.go:55:func (t *SYN223Token) RemoveFromBlacklist(addr string) {
./internal/tokens/syn223_token.go:62:func (t *SYN223Token) Transfer(from, to string, amount uint64) error {
./internal/tokens/syn223_token.go:82:func (t *SYN223Token) BalanceOf(addr string) uint64 {
./core/rpc_webrtc.go:13:func NewWebRTCRPC() *WebRTCRPC {
./core/rpc_webrtc.go:19:func (r *WebRTCRPC) Connect(id string) <-chan []byte {
./core/rpc_webrtc.go:28:func (r *WebRTCRPC) Send(id string, msg []byte) bool {
./core/rpc_webrtc.go:44:func (r *WebRTCRPC) Disconnect(id string) {
./internal/tokens/syn1100.go:18:func NewSYN1100Token() *SYN1100Token {
./internal/tokens/syn1100.go:23:func (t *SYN1100Token) AddRecord(id TokenID, owner string, data []byte) error {
./internal/tokens/syn1100.go:32:func (t *SYN1100Token) GrantAccess(id TokenID, grantee string) error {
./internal/tokens/syn1100.go:42:func (t *SYN1100Token) RevokeAccess(id TokenID, grantee string) error {
./internal/tokens/syn1100.go:52:func (t *SYN1100Token) GetRecord(id TokenID, caller string) ([]byte, error) {
./core/regulatory_node.go:14:func NewRegulatoryNode(id string, mgr *RegulatoryManager) *RegulatoryNode {
./core/regulatory_node.go:23:func (n *RegulatoryNode) ApproveTransaction(tx Transaction) bool {
./core/regulatory_node.go:29:func (n *RegulatoryNode) FlagEntity(addr, reason string) {
./core/regulatory_node.go:36:func (n *RegulatoryNode) Logs(addr string) []string {
./core/address.go:16:func StringToAddress(s string) (Address, error) {
./core/address.go:28:func (a Address) Hex() string { return string(a) }
./core/address.go:32:func (a Address) Bytes() []byte {
./core/address.go:42:func (a Address) Short() string {
./core/address.go:51:func (a Address) String() string { return a.Hex() }
./internal/tokens/index.go:10:func NewRegistry() *Registry {
./internal/tokens/index.go:15:func (r *Registry) NextID() TokenID {
./internal/tokens/index.go:21:func (r *Registry) Register(t Token) {
./internal/tokens/index.go:26:func (r *Registry) Get(id TokenID) (Token, bool) {
./internal/tokens/index.go:32:func (r *Registry) GetBySymbol(symbol string) (Token, bool) {
./internal/tokens/index.go:51:func (r *Registry) Info(id TokenID) (TokenInfo, bool) {
./internal/tokens/index.go:66:func (r *Registry) InfoBySymbol(symbol string) (TokenInfo, bool) {
./internal/tokens/index.go:75:func (r *Registry) List() []TokenInfo {
./core/plasma_operations.go:7:func (b *PlasmaBridge) Deposit(owner, token string, amount uint64) error {
./core/plasma_operations.go:16:func (b *PlasmaBridge) StartExit(owner, token string, amount uint64) (uint64, error) {
./core/plasma_operations.go:29:func (b *PlasmaBridge) FinalizeExit(nonce uint64) error {
./core/plasma_operations.go:41:func (b *PlasmaBridge) GetExit(nonce uint64) (*PlasmaExit, error) {
./core/plasma_operations.go:52:func (b *PlasmaBridge) ListExits(owner string) []*PlasmaExit {
./core/syn1300.go:32:func NewSupplyChainRegistry() *SupplyChainRegistry {
./core/syn1300.go:37:func (r *SupplyChainRegistry) Register(id, desc, owner, location string) (*SupplyChainAsset, error) {
./core/syn1300.go:48:func (r *SupplyChainRegistry) Update(id, location, status, note string) error {
./core/syn1300.go:60:func (r *SupplyChainRegistry) Get(id string) (*SupplyChainAsset, bool) {
./contract_management.go:11:func NewContractManager(reg *ContractRegistry) *ContractManager {
./contract_management.go:16:func (m *ContractManager) Transfer(addr, newOwner string) error {
./contract_management.go:28:func (m *ContractManager) Pause(addr string) error {
./contract_management.go:40:func (m *ContractManager) Resume(addr string) error {
./contract_management.go:52:func (m *ContractManager) Upgrade(addr string, wasm []byte, gasLimit uint64) error {
./contract_management.go:70:func (m *ContractManager) Info(addr string) (*Contract, error) {
./internal/p2p/noise_transport.go:27:func NewNoiseTransport() (*NoiseTransport, error) {
./internal/p2p/noise_transport.go:37:func (t *NoiseTransport) Dial(ctx context.Context, addr string) (net.Conn, error) {
./internal/p2p/noise_transport.go:51:func (t *NoiseTransport) Listen(ctx context.Context, addr string) (net.Listener, error) {
./internal/p2p/noise_transport.go:67:func (l *noiseListener) Accept() (net.Conn, error) {
./internal/p2p/noise_transport.go:83:func (c *NoiseConn) Write(p []byte) (int, error) {
./internal/p2p/noise_transport.go:99:func (c *NoiseConn) Read(p []byte) (int, error) {
./internal/p2p/noise_transport.go:118:func (t *NoiseTransport) handshake(conn net.Conn, initiator bool) (net.Conn, error) {
./core/stake_penalty.go:7:func NewStakePenaltyManager() *StakePenaltyManager { return &StakePenaltyManager{} }
./core/stake_penalty.go:10:func (spm *StakePenaltyManager) Slash(sn *StakingNode, addr string, penalty uint64) {
./core/stake_penalty.go:15:func (spm *StakePenaltyManager) Reward(sn *StakingNode, addr string, reward uint64) {
./internal/nodes/optimization_nodes/optimization.go:25:func (o *FeeOptimizer) Optimize(txs []Transaction) []Transaction {
./core/sidechain_ops.go:11:func NewSidechainOps(reg *SidechainRegistry) *SidechainOps {
./core/sidechain_ops.go:16:func (o *SidechainOps) Deposit(chainID, from string, amount uint64) error {
./core/sidechain_ops.go:28:func (o *SidechainOps) Withdraw(chainID, from string, amount uint64, proof string) error {
./core/sidechain_ops.go:47:func (o *SidechainOps) EscrowBalance(chainID, addr string) (uint64, error) {
./core/opcode.go:71:func Catalogue() []OpcodeInfo {
./core/opcode.go:83:func Opcodes() map[Opcode]string {
./core/opcode.go:95:func Register(op Opcode, fn OpcodeFunc) {
./core/opcode.go:105:func Dispatch(ctx OpContext, op Opcode) error {
./core/opcode.go:121:func wrap(name string) OpcodeFunc {
./core/opcode.go:1611:func init() {
./core/opcode.go:1639:func (op Opcode) Hex() string { return fmt.Sprintf("0x%06X", uint32(op)) }
./core/opcode.go:1642:func (op Opcode) Bytes() []byte {
./core/opcode.go:1651:func (op Opcode) String() string { return op.Hex() }
./core/opcode.go:1654:func ParseOpcode(b []byte) (Opcode, error) {
./core/opcode.go:1662:func MustParseOpcode(b []byte) Opcode {
./core/opcode.go:1672:func DebugDump() []string {
./core/opcode.go:1691:func ToBytecode(fn string) ([]byte, error) {
./core/opcode.go:1700:func HexDump(fn string) (string, error) {
./compliance_management.go:23:func NewComplianceManager() *ComplianceManager {
./compliance_management.go:31:func (m *ComplianceManager) Suspend(addr string) {
./compliance_management.go:38:func (m *ComplianceManager) Resume(addr string) {
./compliance_management.go:45:func (m *ComplianceManager) Whitelist(addr string) {
./compliance_management.go:52:func (m *ComplianceManager) Unwhitelist(addr string) {
./compliance_management.go:59:func (m *ComplianceManager) Status(addr string) (suspended, whitelisted bool) {
./compliance_management.go:68:func (m *ComplianceManager) ReviewTransaction(tx Transaction) error {
./internal/auth/audit.go:21:func NewStdAuditLogger(w io.Writer) *StdAuditLogger {
./internal/auth/audit.go:26:func (l *StdAuditLogger) Log(userID string, perm Permission, allowed bool, metadata map[string]any) {
./holographic.go:10:func SplitHolographic(id string, data []byte, n int) HolographicFrame {
./holographic.go:30:func ReconstructHolographic(frame HolographicFrame) []byte {
./core/nat_traversal.go:14:func NewNATManager() *NATManager {
./core/nat_traversal.go:19:func (n *NATManager) MapPort(id string, port int) {
./core/nat_traversal.go:26:func (n *NATManager) GetPort(id string) (int, bool) {
./core/nat_traversal.go:34:func (n *NATManager) RemoveMapping(id string) {
./core/nat_traversal.go:41:func (n *NATManager) Map(port int) { n.MapPort("self", port) }
./core/nat_traversal.go:44:func (n *NATManager) Unmap() { n.RemoveMapping("self") }
./core/nat_traversal.go:48:func (n *NATManager) SetExternalIP(ip string) {
./core/nat_traversal.go:55:func (n *NATManager) ExternalIP() string {
./firewall.go:16:func NewFirewall() *Firewall {
./firewall.go:25:func (f *Firewall) BlockAddress(addr string) {
./firewall.go:32:func (f *Firewall) UnblockAddress(addr string) {
./firewall.go:39:func (f *Firewall) IsAddressBlocked(addr string) bool {
./firewall.go:47:func (f *Firewall) BlockToken(id string) {
./firewall.go:54:func (f *Firewall) UnblockToken(id string) {
./firewall.go:61:func (f *Firewall) IsTokenBlocked(id string) bool {
./firewall.go:69:func (f *Firewall) BlockIP(ip string) {
./firewall.go:76:func (f *Firewall) UnblockIP(ip string) {
./firewall.go:83:func (f *Firewall) IsIPBlocked(ip string) bool {
./firewall.go:91:func (f *Firewall) Rules() (addrs, tokens, ips []string) {
./anomaly_detection.go:18:func NewAnomalyDetector(threshold float64) *AnomalyDetector {
./anomaly_detection.go:23:func (a *AnomalyDetector) Update(v float64) {
./anomaly_detection.go:33:func (a *AnomalyDetector) IsAnomalous(v float64) bool {
./energy_efficiency.go:18:func NewEnergyEfficiencyTracker() *EnergyEfficiencyTracker {
./energy_efficiency.go:23:func (t *EnergyEfficiencyTracker) Record(validator string, txProcessed int, energyKWh float64) {
./energy_efficiency.go:34:func (t *EnergyEfficiencyTracker) Efficiency(validator string) (float64, bool) {
./energy_efficiency.go:45:func (t *EnergyEfficiencyTracker) NetworkAverage() float64 {
./energy_efficiency.go:62:func (t *EnergyEfficiencyTracker) Stats(validator string) (EfficiencyRecord, bool) {
./energy_efficiency.go:70:func (t *EnergyEfficiencyTracker) Reset(validator string) {
./core/rollup_management.go:9:func NewRollupManager(agg *RollupAggregator) *RollupManager {
./core/rollup_management.go:14:func (m *RollupManager) Pause() {
./core/rollup_management.go:19:func (m *RollupManager) Resume() {
./core/rollup_management.go:24:func (m *RollupManager) Status() bool {
./data_distribution.go:19:func NewDataDistribution() *DataDistribution {
./data_distribution.go:24:func (d *DataDistribution) Offer(nodeID string, meta ContentMeta) {
./data_distribution.go:37:func (d *DataDistribution) Revoke(nodeID, contentID string) {
./data_distribution.go:49:func (d *DataDistribution) Meta(contentID string) (ContentMeta, bool) {
./data_distribution.go:60:func (d *DataDistribution) Locations(contentID string) []string {
./ai_inference_analysis.go:22:func NewInferenceEngine() *InferenceEngine {
./ai_inference_analysis.go:27:func (e *InferenceEngine) LoadModel(hash string, data []byte) {
./ai_inference_analysis.go:34:func (e *InferenceEngine) Run(hash string, input []byte) ([]byte, error) {
./ai_inference_analysis.go:46:func (e *InferenceEngine) Analyse(txIDs []string) []FraudResult {
./core/loanpool_proposal.go:20:func NewLoanProposal(id uint64, creator, recipient, typ string, amount uint64, desc string, duration time.Duration) *LoanProposal {
./core/loanpool_proposal.go:34:func (p *LoanProposal) Vote(voter string) {
./core/loanpool_proposal.go:39:func (p *LoanProposal) VoteCount() int {
./core/loanpool_proposal.go:44:func (p *LoanProposal) IsExpired(now time.Time) bool {
./address_zero.go:9:func IsZeroAddress(addr string) bool {
./cross_chain_connection.go:27:func NewConnectionManager() *ConnectionManager {
./cross_chain_connection.go:32:func (m *ConnectionManager) OpenConnection(localChain, remoteChain string) string {
./cross_chain_connection.go:46:func (m *ConnectionManager) CloseConnection(id string) error {
./cross_chain_connection.go:62:func (m *ConnectionManager) GetConnection(id string) (*ChainConnection, bool) {
./cross_chain_connection.go:70:func (m *ConnectionManager) ListConnections() []*ChainConnection {
./core/quorum_tracker.go:14:func NewQuorumTracker(required int) *QuorumTracker {
./core/quorum_tracker.go:22:func (qt *QuorumTracker) Join(id string) {
./core/quorum_tracker.go:29:func (qt *QuorumTracker) Leave(id string) {
./core/quorum_tracker.go:36:func (qt *QuorumTracker) Count() int {
./core/quorum_tracker.go:43:func (qt *QuorumTracker) Reached() bool {
./core/liquidity_views.go:14:func NewLiquidityPoolView(p *LiquidityPool) LiquidityPoolView {
./core/liquidity_views.go:26:func (r *LiquidityPoolRegistry) PoolInfo(id string) (LiquidityPoolView, bool) {
./core/liquidity_views.go:35:func (r *LiquidityPoolRegistry) PoolViews() []LiquidityPoolView {
./core/plasma.go:23:func NewPlasmaBridge() *PlasmaBridge {
./core/zero_trust_data_channels.go:22:func NewZeroTrustEngine() *ZeroTrustEngine {
./core/zero_trust_data_channels.go:27:func (e *ZeroTrustEngine) OpenChannel(id string, key []byte) error {
./core/zero_trust_data_channels.go:38:func (e *ZeroTrustEngine) Send(id string, payload []byte) ([]byte, error) {
./core/zero_trust_data_channels.go:56:func (e *ZeroTrustEngine) Messages(id string) [][]byte {
./core/zero_trust_data_channels.go:73:func (e *ZeroTrustEngine) CloseChannel(id string) error {
./core/kademlia.go:19:func NewKademlia() *Kademlia {
./core/kademlia.go:24:func (k *Kademlia) Store(key string, value []byte) {
./core/kademlia.go:31:func (k *Kademlia) FindValue(key string) ([]byte, bool) {
./core/kademlia.go:42:func Distance(a, b string) *big.Int {
./core/kademlia.go:61:func (k *Kademlia) Closest(target string, n int) []string {
./core/compliance_management.go:16:func NewComplianceManager() *ComplianceManager {
./core/compliance_management.go:24:func (m *ComplianceManager) Suspend(addr string) {
./core/compliance_management.go:31:func (m *ComplianceManager) Resume(addr string) {
./core/compliance_management.go:38:func (m *ComplianceManager) Whitelist(addr string) {
./core/compliance_management.go:45:func (m *ComplianceManager) Unwhitelist(addr string) {
./core/compliance_management.go:52:func (m *ComplianceManager) Status(addr string) (suspended, whitelisted bool) {
./core/compliance_management.go:61:func (m *ComplianceManager) ReviewTransaction(tx Transaction) error {
./core/idwallet_registration.go:15:func NewIDRegistry() *IDRegistry {
./core/idwallet_registration.go:20:func (r *IDRegistry) Register(addr, info string) error {
./core/idwallet_registration.go:31:func (r *IDRegistry) Info(addr string) (string, bool) {
./core/vm_sandbox_management.go:29:func NewSandboxManager() *SandboxManager {
./core/vm_sandbox_management.go:34:func (m *SandboxManager) StartSandbox(id, contractAddr string, gasLimit, memoryLimit uint64) (*SandboxInfo, error) {
./core/vm_sandbox_management.go:54:func (m *SandboxManager) StopSandbox(id string) error {
./core/vm_sandbox_management.go:66:func (m *SandboxManager) ResetSandbox(id string) error {
./core/vm_sandbox_management.go:78:func (m *SandboxManager) SandboxStatus(id string) (*SandboxInfo, bool) {
./core/vm_sandbox_management.go:86:func (m *SandboxManager) ListSandboxes() []*SandboxInfo {
./core/government_authority_node.go:10:func NewGovernmentAuthorityNode(addr, role, department string) *GovernmentAuthorityNode {
./core/central_banking_node.go:10:func NewCentralBankingNode(id, addr string, ledger *Ledger, policy string) *CentralBankingNode {
./core/central_banking_node.go:18:func (n *CentralBankingNode) UpdatePolicy(policy string) {
./core/central_banking_node.go:23:func (n *CentralBankingNode) Mint(to string, amount uint64) {
./core/node.go:23:func NewNode(id, addr string, ledger *Ledger) *Node {
./core/node.go:38:func (n *Node) AddTransaction(tx *Transaction) error {
./core/node.go:48:func (n *Node) ValidateTransaction(tx *Transaction) error {
./core/node.go:59:func (n *Node) MineBlock() *Block {
./core/node.go:98:func (n *Node) SetStake(addr string, amount uint64) error {
./core/node.go:106:func (n *Node) eligibleStakes() map[string]uint64 {
./core/node.go:117:func (n *Node) ReportDoubleSign(addr string) {
./core/node.go:122:func (n *Node) ReportDowntime(addr string) {
./core/node.go:127:func (n *Node) Rehabilitate(addr string) {
./core/node.go:131:func (n *Node) slash(addr string) {
./core/gas.go:13:func GasCost(op Opcode) uint64 {
./core/gas.go:19:func initGasTable() {
./core/transaction.go:42:func NewTransaction(from, to string, amount, fee, nonce uint64) *Transaction {
./core/transaction.go:58:func (t *Transaction) Hash() string {
./core/transaction.go:75:func (t *Transaction) Verify(pub *ecdsa.PublicKey) bool {
./core/transaction.go:84:func (t *Transaction) AttachBiometric(userID string, biometric []byte, svc *BiometricService) error {
./core/biometrics_auth.go:15:func NewBiometricsAuth() *BiometricsAuth {
./core/biometrics_auth.go:20:func (b *BiometricsAuth) Enroll(addr string, biometric []byte) {
./core/biometrics_auth.go:27:func (b *BiometricsAuth) Verify(addr string, biometric []byte) bool {
./core/biometrics_auth.go:38:func (b *BiometricsAuth) Remove(addr string) {
./core/biometrics_auth.go:45:func (b *BiometricsAuth) Enrolled(addr string) bool {
./core/biometrics_auth.go:54:func (b *BiometricsAuth) List() []string {
./core/mining_node.go:19:func NewMiningNode(hashRate uint64) *MiningNode {
./core/mining_node.go:24:func (mn *MiningNode) Start() {
./core/mining_node.go:31:func (mn *MiningNode) Stop() {
./core/mining_node.go:38:func (mn *MiningNode) IsMining() bool {
./core/mining_node.go:45:func (mn *MiningNode) Mine(data []byte) (string, error) {
./core/mining_node.go:60:func (mn *MiningNode) HashRateHint() uint64 {
./core/syn800_token.go:25:func NewAssetRegistry() *AssetRegistry {
./core/syn800_token.go:30:func (r *AssetRegistry) Register(id, desc string, valuation uint64, loc, typ, cert string) (*AssetMetadata, error) {
./core/syn800_token.go:40:func (r *AssetRegistry) UpdateValuation(id string, valuation uint64) error {
./core/syn800_token.go:51:func (r *AssetRegistry) Get(id string) (*AssetMetadata, bool) {
./core/fees.go:33:func CalculateBaseFee(recent []uint64, adjustment float64) uint64 {
./core/fees.go:49:func CalculateVariableFee(gasUnits, gasPrice uint64) uint64 {
./core/fees.go:54:func CalculatePriorityFee(tip uint64) uint64 { return tip }
./core/fees.go:57:func FeeForTransfer(dataSize, baseFee, variableRate, tip uint64) FeeBreakdown {
./core/fees.go:64:func FeeForPurchase(calls, baseFee, variableRate, tip uint64) FeeBreakdown {
./core/fees.go:71:func FeeForTokenUsage(computationUnits, baseFee, variableRate, tip uint64) FeeBreakdown {
./core/fees.go:78:func FeeForContract(complexityFactor, baseFee, variableRate, tip uint64) FeeBreakdown {
./core/fees.go:85:func FeeForWalletVerification(securityLevel, baseFee, variableRate, tip uint64) FeeBreakdown {
./core/fees.go:94:func FeeForValidatedTransfer(dataSize, baseFee, variableRate, tip uint64, validated bool) FeeBreakdown {
./core/fees.go:115:func DistributeFees(total uint64) FeeDistribution {
./core/fees.go:129:func ApplyFeeCapFloor(fee, cap, floor uint64) uint64 {
./core/fees.go:147:func (p FeePolicy) Enforce(fee uint64) (uint64, string) {
./core/fees.go:161:func AdjustFeeRates(baseFee, variableRate uint64, load float64) (uint64, uint64) {
./core/fees.go:174:func EstimateFee(txType TransactionType, units, baseFee, variableRate, tip uint64) FeeBreakdown {
./core/fees.go:194:func ShareProportional(total uint64, weights map[string]uint64) map[string]uint64 {
./core/fees.go:227:func NewFeeDistributionContract(l *Ledger) *FeeDistributionContract {
./core/fees.go:232:func (f *FeeDistributionContract) Distribute(shares map[string]uint64) {
./core/fees.go:240:func AdjustForBlockUtilization(pool uint64, used, capacity int) uint64 {
./core/loanpool_apply.go:25:func NewLoanPoolApply(pool *LoanPool) *LoanPoolApply {
./core/loanpool_apply.go:34:func (l *LoanPoolApply) Submit(applicant string, amount uint64, termMonths uint32, purpose string) uint64 {
./core/loanpool_apply.go:49:func (l *LoanPoolApply) Vote(voter string, id uint64) error {
./core/loanpool_apply.go:59:func (l *LoanPoolApply) Process() {
./core/loanpool_apply.go:68:func (l *LoanPoolApply) Disburse(id uint64) error {
./core/loanpool_apply.go:85:func (l *LoanPoolApply) Get(id uint64) (*LoanApplication, bool) {
./core/loanpool_apply.go:91:func (l *LoanPoolApply) List() []*LoanApplication {
./core/syn500.go:23:func NewSYN500Token(name, symbol, owner string, decimals uint8, supply uint64) *SYN500Token {
./core/syn500.go:28:func (t *SYN500Token) Grant(addr string, tier int, max uint64) {
./core/syn500.go:33:func (t *SYN500Token) Use(addr string) error {
./core/authority_apply.go:32:func NewAuthorityApplicationManager(reg *AuthorityNodeRegistry, ttl time.Duration) *AuthorityApplicationManager {
./core/authority_apply.go:42:func (m *AuthorityApplicationManager) Submit(candidate, role, desc string) string {
./core/authority_apply.go:61:func (m *AuthorityApplicationManager) Vote(voter, id string, approve bool) error {
./core/authority_apply.go:82:func (m *AuthorityApplicationManager) Finalize(id string) error {
./core/authority_apply.go:101:func (m *AuthorityApplicationManager) Tick(now time.Time) {
./core/authority_apply.go:112:func (m *AuthorityApplicationManager) Get(id string) (*AuthorityApplication, error) {
./core/authority_apply.go:123:func (m *AuthorityApplicationManager) List() []*AuthorityApplication {
./core/light_node.go:12:func NewLightNode(id nodes.Address) *LightNode {
./core/light_node.go:17:func (n *LightNode) AddHeader(h nodes.BlockHeader) { n.headers = append(n.headers, h) }
./core/light_node.go:20:func (n *LightNode) LatestHeader() (nodes.BlockHeader, bool) {
./core/light_node.go:28:func (n *LightNode) Headers() []nodes.BlockHeader {
./core/syn3800.go:26:func NewGrantRegistry() *GrantRegistry {
./core/syn3800.go:31:func (r *GrantRegistry) CreateGrant(beneficiary, name string, amount uint64) uint64 {
./core/syn3800.go:41:func (r *GrantRegistry) Disburse(id uint64, amount uint64, note string) error {
./core/syn3800.go:59:func (r *GrantRegistry) GetGrant(id uint64) (*GrantRecord, bool) {
./core/syn3800.go:71:func (r *GrantRegistry) ListGrants() []*GrantRecord {
./core/initialization_replication.go:14:func NewInitService(r *Replicator) *InitService {
./core/initialization_replication.go:19:func (i *InitService) Start() {
./core/initialization_replication.go:30:func (i *InitService) Stop() {
./core/address_zero.go:9:func IsZeroAddress(addr string) bool {
./core/syn3200.go:32:func NewBillRegistry() *BillRegistry {
./core/syn3200.go:37:func (r *BillRegistry) Create(id, issuer, payer string, amt uint64, due time.Time, meta string) (*Bill, error) {
./core/syn3200.go:47:func (r *BillRegistry) Pay(id, payer string, amt uint64) error {
./core/syn3200.go:65:func (r *BillRegistry) Adjust(id string, amt uint64) error {
./core/syn3200.go:75:func (r *BillRegistry) Get(id string) (*Bill, bool) {
./core/dao_staking.go:15:func NewDAOStaking() *DAOStaking {
./core/dao_staking.go:20:func (s *DAOStaking) Stake(addr string, amount uint64) {
./core/dao_staking.go:27:func (s *DAOStaking) Unstake(addr string, amount uint64) error {
./core/dao_staking.go:39:func (s *DAOStaking) Balance(addr string) uint64 {
./contracts.go:39:func NewContractRegistry(vm VirtualMachine) *ContractRegistry {
./contracts.go:49:func CompileWASM(src []byte) ([]byte, string, error) {
./contracts.go:60:func (r *ContractRegistry) Deploy(wasm []byte, manifest string, gasLimit uint64, owner string) (string, error) {
./contracts.go:84:func (r *ContractRegistry) Invoke(addr, method string, args []byte, gasLimit uint64) ([]byte, uint64, error) {
./contracts.go:101:func (r *ContractRegistry) List() []*Contract {
./contracts.go:112:func (r *ContractRegistry) Get(addr string) (*Contract, bool) {
./core/syn2500_token.go:18:func NewSyn2500Member(id, addr string, power uint64, meta map[string]string) *Syn2500Member {
./core/syn2500_token.go:33:func (m *Syn2500Member) UpdateVotingPower(power uint64) {
./core/syn2500_token.go:44:func NewSyn2500Registry() *Syn2500Registry {
./core/syn2500_token.go:49:func (r *Syn2500Registry) AddMember(m *Syn2500Member) {
./core/syn2500_token.go:56:func (r *Syn2500Registry) GetMember(id string) (*Syn2500Member, bool) {
./core/syn2500_token.go:64:func (r *Syn2500Registry) RemoveMember(id string) {
./core/syn2500_token.go:71:func (r *Syn2500Registry) ListMembers() []*Syn2500Member {
./core/historical_node.go:21:func NewHistoricalNode() *HistoricalNode {
./core/historical_node.go:29:func (h *HistoricalNode) ArchiveBlock(summary nodes.BlockSummary) error {
./core/historical_node.go:44:func (h *HistoricalNode) GetBlockByHeight(height uint64) (nodes.BlockSummary, bool) {
./core/historical_node.go:52:func (h *HistoricalNode) GetBlockByHash(hash string) (nodes.BlockSummary, bool) {
./core/historical_node.go:60:func (h *HistoricalNode) TotalBlocks() int {
./content_node.go:17:func NewContentNetworkNode(id, addr string) *ContentNetworkNode {
./content_node.go:26:func (n *ContentNetworkNode) Register(meta ContentMeta) {
./content_node.go:33:func (n *ContentNetworkNode) Unregister(id string) {
./content_node.go:40:func (n *ContentNetworkNode) Content(id string) (ContentMeta, bool) {
./content_node.go:48:func (n *ContentNetworkNode) List() []ContentMeta {
./core/dao.go:27:func NewDAOManager() *DAOManager {
./core/dao.go:32:func (m *DAOManager) Create(name, creator string) *DAO {
./core/dao.go:43:func (m *DAOManager) Join(id, addr string) error {
./core/dao.go:60:func (m *DAOManager) Leave(id, addr string) error {
./core/dao.go:74:func (m *DAOManager) Info(id string) (*DAO, error) {
./core/dao.go:85:func (m *DAOManager) List() []*DAO {
./core/gateway_node.go:22:func NewGatewayNode(id nodes.Address, cfg GatewayConfig) *GatewayNode {
./core/gateway_node.go:31:func (g *GatewayNode) RegisterEndpoint(name string, fn func([]byte) error) {
./core/gateway_node.go:36:func (g *GatewayNode) Handle(name string, data []byte) error {
./core/gateway_node.go:44:func (g *GatewayNode) RemoveEndpoint(name string) {
./core/gateway_node.go:49:func (g *GatewayNode) Endpoints() []string {
./core/cross_chain_contracts.go:22:func NewCrossChainRegistry() *CrossChainRegistry {
./core/cross_chain_contracts.go:27:func (r *CrossChainRegistry) RegisterMapping(local, remoteChain, remoteAddr string) {
./core/cross_chain_contracts.go:34:func (r *CrossChainRegistry) GetMapping(local string) (*ContractMapping, bool) {
./core/cross_chain_contracts.go:42:func (r *CrossChainRegistry) ListMappings() []*ContractMapping {
./core/cross_chain_contracts.go:53:func (r *CrossChainRegistry) RemoveMapping(local string) error {
./biometric_security_node.go:14:func NewBiometricSecurityNode(id string, auth *BiometricsAuth) *BiometricSecurityNode {
./biometric_security_node.go:22:func (b *BiometricSecurityNode) GetID() string { return b.id }
./biometric_security_node.go:25:func (b *BiometricSecurityNode) Enroll(addr string, biometric []byte) {
./biometric_security_node.go:30:func (b *BiometricSecurityNode) Remove(addr string) {
./biometric_security_node.go:35:func (b *BiometricSecurityNode) Authenticate(addr string, biometric []byte) bool {
./biometric_security_node.go:40:func (b *BiometricSecurityNode) SecureExecute(addr string, biometric []byte, fn func() error) error {
./core/cross_chain.go:24:func NewBridgeRegistry() *BridgeRegistry {
./core/cross_chain.go:29:func (r *BridgeRegistry) RegisterBridge(source, target, relayer string) (*Bridge, error) {
./core/cross_chain.go:45:func (r *BridgeRegistry) ListBridges() []*Bridge {
./core/cross_chain.go:56:func (r *BridgeRegistry) GetBridge(id string) (*Bridge, bool) {
./core/cross_chain.go:64:func (r *BridgeRegistry) AuthorizeRelayer(id, relayer string) error {
./core/cross_chain.go:79:func (r *BridgeRegistry) RevokeRelayer(id, relayer string) error {
./core/forensic_node.go:21:func NewForensicNode() *ForensicNode {
./core/forensic_node.go:26:func (f *ForensicNode) RecordTransaction(tx nodes.TransactionLite) error {
./core/forensic_node.go:34:func (f *ForensicNode) RecordNetworkTrace(trace nodes.NetworkTrace) error {
./core/forensic_node.go:42:func (f *ForensicNode) Transactions() []nodes.TransactionLite {
./core/forensic_node.go:51:func (f *ForensicNode) NetworkTraces() []nodes.NetworkTrace {
./core/consensus_validator_management.go:17:func NewValidatorManager(minStake uint64) *ValidatorManager {
./core/consensus_validator_management.go:26:func (vm *ValidatorManager) Add(addr string, stake uint64) error {
./core/consensus_validator_management.go:38:func (vm *ValidatorManager) Remove(addr string) {
./core/consensus_validator_management.go:46:func (vm *ValidatorManager) Slash(addr string) {
./core/consensus_validator_management.go:56:func (vm *ValidatorManager) Eligible() map[string]uint64 {
./core/consensus_validator_management.go:69:func (vm *ValidatorManager) Stake(addr string) uint64 {
./core/elected_authority_node.go:12:func NewElectedAuthorityNode(addr, role string, term time.Duration) *ElectedAuthorityNode {
./core/elected_authority_node.go:18:func (n *ElectedAuthorityNode) IsActive(now time.Time) bool {
./ai_model_management.go:27:func NewModelMarketplace() *ModelMarketplace {
./ai_model_management.go:32:func (m *ModelMarketplace) AddListing(hash, cid, seller string, price uint64) string {
./ai_model_management.go:49:func (m *ModelMarketplace) Get(id string) (ModelListing, bool) {
./ai_model_management.go:57:func (m *ModelMarketplace) List() []ModelListing {
./ai_model_management.go:70:func (m *ModelMarketplace) Update(id string, price uint64) error {
./ai_model_management.go:84:func (m *ModelMarketplace) Remove(id, seller string) error {
./core/dao_proposal.go:29:func NewProposalManager() *ProposalManager {
./core/dao_proposal.go:34:func (pm *ProposalManager) CreateProposal(dao *DAO, creator, desc string) *DAOProposal {
./core/dao_proposal.go:49:func (pm *ProposalManager) Vote(id, voter string, weight uint64, support bool) error {
./core/dao_proposal.go:69:func (pm *ProposalManager) Results(id string) (yes, no uint64, err error) {
./core/dao_proposal.go:88:func (pm *ProposalManager) Execute(id string) error {
./core/dao_proposal.go:102:func (pm *ProposalManager) Get(id string) (*DAOProposal, error) {
./core/dao_proposal.go:113:func (pm *ProposalManager) List() []*DAOProposal {
./core/cross_consensus_scaling_networks.go:23:func NewConsensusNetworkManager() *ConsensusNetworkManager {
./core/cross_consensus_scaling_networks.go:28:func (m *ConsensusNetworkManager) RegisterNetwork(source, target string) int {
./core/cross_consensus_scaling_networks.go:38:func (m *ConsensusNetworkManager) ListNetworks() []ConsensusNetwork {
./core/cross_consensus_scaling_networks.go:49:func (m *ConsensusNetworkManager) GetNetwork(id int) (ConsensusNetwork, error) {
./ai.go:42:func NewAIService() *AIService {
./ai.go:51:func (s *AIService) PredictFraud(txJSON []byte) (float64, error) {
./ai.go:61:func (s *AIService) OptimiseBaseFee(statsJSON []byte) (uint64, error) {
./ai.go:71:func (s *AIService) ForecastVolume(statsJSON []byte) (uint64, error) {
./ai.go:81:func (s *AIService) PublishModel(cid string, royaltyBps uint16) (string, error) {
./ai.go:96:func (s *AIService) FetchModel(hash string) (AIModelMetadata, bool) {
./ai.go:104:func (s *AIService) ListModel(hash, cid, seller string, price uint64) string {
./ai.go:109:func (s *AIService) BuyModel(listingID, buyer string, amount uint64) (string, error) {
./ai.go:131:func (s *AIService) RentModel(listingID, renter string, hours int, amount uint64) (string, error) {
./ai.go:154:func (s *AIService) ReleaseEscrow(id string) error {
./core/syn1600.go:19:func NewMusicToken(title, artist, album string) *MusicToken {
./core/syn1600.go:29:func (m *MusicToken) Info() (string, string, string) {
./core/syn1600.go:36:func (m *MusicToken) Update(title, artist, album string) {
./core/syn1600.go:51:func (m *MusicToken) SetRoyaltyShare(addr string, share uint64) {
./core/syn1600.go:60:func (m *MusicToken) Distribute(amount uint64) (map[string]uint64, error) {
./core/cross_chain_bridge.go:39:func NewBridgeManager(l *Ledger) *BridgeManager {
./core/cross_chain_bridge.go:48:func (m *BridgeManager) RegisterBridge(source, target, relayer string) int {
./core/cross_chain_bridge.go:62:func (m *BridgeManager) ListBridges() []*AssetBridge {
./core/cross_chain_bridge.go:73:func (m *BridgeManager) GetBridge(id int) (*AssetBridge, error) {
./core/cross_chain_bridge.go:84:func (m *BridgeManager) AuthorizeRelayer(id int, addr string) error {
./core/cross_chain_bridge.go:96:func (m *BridgeManager) RevokeRelayer(id int, addr string) error {
./core/cross_chain_bridge.go:108:func (m *BridgeManager) Deposit(bridgeID int, from, to string, amount uint64, tokenID string) (int, error) {
./core/cross_chain_bridge.go:128:func (m *BridgeManager) Claim(transferID int, proof string) error {
./core/cross_chain_bridge.go:147:func (m *BridgeManager) GetTransfer(id int) (*BridgeTransferRecord, error) {
./core/cross_chain_bridge.go:158:func (m *BridgeManager) ListTransfers() []*BridgeTransferRecord {
./core/cross_chain_bridge.go:187:func NewBridgeTransferManager() *BridgeTransferManager {
./core/cross_chain_bridge.go:192:func (m *BridgeTransferManager) Deposit(bridgeID, from, to string, amount uint64, tokenID string) (*BridgeTransfer, error) {
./core/cross_chain_bridge.go:211:func (m *BridgeTransferManager) Claim(id, proof string) error {
./core/cross_chain_bridge.go:226:func (m *BridgeTransferManager) GetTransfer(id string) (*BridgeTransfer, bool) {
./core/cross_chain_bridge.go:234:func (m *BridgeTransferManager) ListTransfers() []*BridgeTransfer {
./core/dao_access_control.go:6:func (d *DAO) AddMember(addr, role string) error {
./core/dao_access_control.go:20:func (d *DAO) RemoveMember(addr string) {
./core/dao_access_control.go:27:func (d *DAO) MemberRole(addr string) (string, bool) {
./core/dao_access_control.go:35:func (d *DAO) MembersList() map[string]string {
./core/contracts.go:39:func NewContractRegistry(vm VirtualMachine) *ContractRegistry {
./core/contracts.go:49:func CompileWASM(src []byte) ([]byte, string, error) {
./core/contracts.go:60:func (r *ContractRegistry) Deploy(wasm []byte, manifest string, gasLimit uint64, owner string) (string, error) {
./core/contracts.go:84:func (r *ContractRegistry) Invoke(addr, method string, args []byte, gasLimit uint64) ([]byte, uint64, error) {
./core/contracts.go:101:func (r *ContractRegistry) List() []*Contract {
./core/contracts.go:112:func (r *ContractRegistry) Get(addr string) (*Contract, bool) {
./core/consensus_specific_node.go:10:func NewConsensusSpecificNode(mode ConsensusMode, id, addr string, ledger *Ledger) *ConsensusSpecificNode {
./core/consensus_specific_node.go:19:func (n *ConsensusSpecificNode) configure() {
./core/swarm.go:13:func NewSwarm() *Swarm {
./core/swarm.go:18:func (s *Swarm) Join(n *Node) {
./core/swarm.go:25:func (s *Swarm) Leave(id string) {
./core/swarm.go:32:func (s *Swarm) Members() []*Node {
./core/swarm.go:44:func (s *Swarm) Broadcast(tx *Transaction) {
./core/swarm.go:51:func (s *Swarm) Peers() []string {
./core/swarm.go:63:func (s *Swarm) StartConsensus() []*Block {
./core/cross_chain_transactions.go:39:func NewCrossChainTxManager(l *Ledger) *CrossChainTxManager {
./core/cross_chain_transactions.go:44:func (m *CrossChainTxManager) LockMint(bridgeID int, from, to, assetID string, amount uint64, proof string) (int, error) {
./core/cross_chain_transactions.go:62:func (m *CrossChainTxManager) BurnRelease(bridgeID int, from, to, assetID string, amount uint64) (int, error) {
./core/cross_chain_transactions.go:80:func (m *CrossChainTxManager) ListTransfers() []*CrossChainTransfer {
./core/cross_chain_transactions.go:91:func (m *CrossChainTxManager) GetTransfer(id int) (*CrossChainTransfer, error) {
./core/consensus.go:38:func NewSynnergyConsensus() *SynnergyConsensus {
./core/consensus.go:55:func (sc *SynnergyConsensus) Threshold(D, S float64) float64 {
./core/consensus.go:63:func (sc *SynnergyConsensus) AdjustWeights(D, S float64) {
./core/consensus.go:89:func (sc *SynnergyConsensus) Tload(D float64) float64 {
./core/consensus.go:97:func (sc *SynnergyConsensus) Tsecurity(threat float64) float64 {
./core/consensus.go:105:func (sc *SynnergyConsensus) Tstake(S float64) float64 {
./core/consensus.go:114:func (sc *SynnergyConsensus) TransitionThreshold(D, threat, S float64) float64 {
./core/consensus.go:120:func (sc *SynnergyConsensus) DifficultyAdjust(oldDifficulty, actualTime, expectedTime float64) float64 {
./core/consensus.go:128:func (sc *SynnergyConsensus) SetAvailability(pow, pos, poh bool) {
./core/consensus.go:135:func (sc *SynnergyConsensus) SetPoWRewards(enabled bool) {
./core/consensus.go:141:func (sc *SynnergyConsensus) SelectValidator(stakes map[string]uint64) string {
./core/consensus.go:167:func (sc *SynnergyConsensus) ValidateSubBlock(sb *SubBlock) bool {
./core/consensus.go:174:func (sc *SynnergyConsensus) MineBlock(b *Block, difficulty uint8) {
./core/consensus.go:189:func clamp(v, min, max float64) float64 {
./core/sharding.go:17:func NewShardManager(shardBits uint8) *ShardManager {
./core/sharding.go:27:func (m *ShardManager) GetLeader(shardID int) (string, bool) {
./core/sharding.go:35:func (m *ShardManager) SetLeader(shardID int, addr string) {
./core/sharding.go:42:func (m *ShardManager) LeaderMap() map[int]string {
./core/sharding.go:53:func (m *ShardManager) SubmitCrossShardTx(fromShard, toShard int, txHash string) {
./core/sharding.go:61:func (m *ShardManager) PullReceipts(shardID int) []string {
./core/sharding.go:71:func (m *ShardManager) Reshard(newBits uint8) {
./core/sharding.go:78:func (m *ShardManager) Rebalance(threshold int) []int {
./core/sharding.go:91:func (m *ShardManager) ShardCount() int {
./core/coin.go:22:func BlockReward(height uint64) uint64 {
./core/coin.go:30:func CirculatingSupply(height uint64) uint64 {
./core/coin.go:43:func RemainingSupply(height uint64) uint64 {
./core/coin.go:53:func InitialPrice(C, R, M, V, T, E float64) float64 {
./core/coin.go:59:func AlphaFactor(volatility, participation, economicStability, normalization float64) float64 {
./core/coin.go:66:func MinimumStake(totalTx, currentReward, circulatingSupply, alpha float64) float64 {
./core/coin.go:75:func LockupDuration(base, V, threshold, sigma float64) float64 {
./core/coin.go:84:func PriceToSupplyRatio(price float64, height uint64) float64 {
./core/cross_chain_agnostic_protocols.go:19:func NewProtocolRegistry() *ProtocolRegistry {
./core/cross_chain_agnostic_protocols.go:24:func (r *ProtocolRegistry) Register(name string) int {
./core/cross_chain_agnostic_protocols.go:34:func (r *ProtocolRegistry) List() []ProtocolDefinition {
./core/cross_chain_agnostic_protocols.go:45:func (r *ProtocolRegistry) Get(id int) (ProtocolDefinition, bool) {
./core/blockchain_compression.go:21:func CompressLedger(l *Ledger) ([]byte, error) {
./core/blockchain_compression.go:38:func DecompressLedger(data []byte) (*Ledger, error) {
./core/blockchain_compression.go:67:func SaveCompressedSnapshot(l *Ledger, path string) error {
./core/blockchain_compression.go:77:func LoadCompressedSnapshot(path string) (*Ledger, error) {
./core/contract_management.go:11:func NewContractManager(reg *ContractRegistry) *ContractManager {
./core/contract_management.go:16:func (m *ContractManager) Transfer(addr, newOwner string) error {
./core/contract_management.go:28:func (m *ContractManager) Pause(addr string) error {
./core/contract_management.go:40:func (m *ContractManager) Resume(addr string) error {
./core/contract_management.go:52:func (m *ContractManager) Upgrade(addr string, wasm []byte, gasLimit uint64) error {
./core/contract_management.go:70:func (m *ContractManager) Info(addr string) (*Contract, error) {
./core/biometric.go:18:func NewBiometricService() *BiometricService {
./core/biometric.go:24:func (b *BiometricService) Enroll(userID string, biometric []byte) {
./core/biometric.go:33:func (b *BiometricService) Verify(userID string, biometric []byte) bool {
./core/replication.go:15:func NewReplicator(l *Ledger) *Replicator {
./core/replication.go:20:func (r *Replicator) Start() {
./core/replication.go:27:func (r *Replicator) Stop() {
./core/replication.go:34:func (r *Replicator) Status() bool {
./core/replication.go:42:func (r *Replicator) ReplicateBlock(hash string) bool {
./core/consensus_specific.go:21:func NewConsensusSwitcher(mode ConsensusMode) *ConsensusSwitcher {
./core/consensus_specific.go:27:func (cs *ConsensusSwitcher) Evaluate(sc *SynnergyConsensus) ConsensusMode {
./core/consensus_specific.go:49:func (cs *ConsensusSwitcher) Mode() ConsensusMode {
./core/authority_nodes.go:25:func NewAuthorityNodeRegistry() *AuthorityNodeRegistry {
./core/authority_nodes.go:30:func (r *AuthorityNodeRegistry) Register(addr, role string) (*AuthorityNode, error) {
./core/authority_nodes.go:42:func (r *AuthorityNodeRegistry) Vote(voterAddr, candidateAddr string) error {
./core/authority_nodes.go:54:func (r *AuthorityNodeRegistry) Electorate(size int) []string {
./core/authority_nodes.go:74:func (r *AuthorityNodeRegistry) IsAuthorityNode(addr string) bool {
./core/authority_nodes.go:82:func (r *AuthorityNodeRegistry) Info(addr string) (*AuthorityNode, error) {
./core/authority_nodes.go:93:func (r *AuthorityNodeRegistry) List() []*AuthorityNode {
./core/authority_nodes.go:100:func (r *AuthorityNodeRegistry) Deregister(addr string) {
./core/private_transactions.go:13:func Encrypt(key, plaintext []byte) ([]byte, error) {
./core/private_transactions.go:31:func Decrypt(key, data []byte) ([]byte, error) {
./core/private_transactions.go:62:func NewPrivateTxManager() *PrivateTxManager {
./core/private_transactions.go:67:func (m *PrivateTxManager) Send(tx PrivateTransaction) {
./core/private_transactions.go:74:func (m *PrivateTxManager) List() []PrivateTransaction {
./core/audit_management.go:24:func NewAuditManager() *AuditManager {
./core/audit_management.go:29:func (m *AuditManager) Log(address, event string, metadata map[string]string) error {
./core/audit_management.go:43:func (m *AuditManager) List(address string) []AuditEntry {
./core/connection_pool.go:21:func NewConnectionPool(max int) *ConnectionPool {
./core/connection_pool.go:30:func (p *ConnectionPool) Acquire(id string) (*Connection, error) {
./core/connection_pool.go:45:func (p *ConnectionPool) Release(id string) {
./core/connection_pool.go:52:func (p *ConnectionPool) Size() int {
./core/connection_pool.go:61:func (p *ConnectionPool) Dial(addr string) (*Connection, error) {
./core/connection_pool.go:66:func (p *ConnectionPool) Close() {
./core/connection_pool.go:79:func (p *ConnectionPool) Stats() PoolStats {
./core/peer_management.go:14:func NewPeerManager() *PeerManager {
./core/peer_management.go:22:func (pm *PeerManager) AddPeer(id, addr string) {
./core/peer_management.go:29:func (pm *PeerManager) RemovePeer(id string) {
./core/peer_management.go:36:func (pm *PeerManager) GetPeer(id string) (string, bool) {
./core/peer_management.go:44:func (pm *PeerManager) ListPeers() []string {
./core/peer_management.go:57:func (pm *PeerManager) Connect(addr string) string {
./core/peer_management.go:64:func (pm *PeerManager) Advertise(id, topic string) {
./core/peer_management.go:71:func (pm *PeerManager) Discover(topic string) []string {
./core/charity.go:24:func (c CharityCategory) String() string {
./core/charity.go:72:func NewCharityPool(lg *logrus.Logger, led StateRW, el electorate, genesis time.Time) *CharityPool {
./core/charity.go:77:func (cp *CharityPool) Deposit(from Address, amount uint64) error {
./core/charity.go:85:func (cp *CharityPool) Register(addr Address, name string, cat CharityCategory) error {
./core/charity.go:96:func (cp *CharityPool) Vote(voter, charity Address) error {
./core/charity.go:105:func (cp *CharityPool) Tick(ts time.Time) {}
./core/charity.go:109:func (cp *CharityPool) Winners(cycle uint64) ([]Address, error) {
./core/charity.go:114:func (cp *CharityPool) GetRegistration(cycle uint64, addr Address) (CharityRegistration, bool, error) {
./core/charity.go:128:func mustJSON(v interface{}) []byte {
./core/access_control.go:12:func NewAccessController() *AccessController {
./core/access_control.go:17:func (a *AccessController) Grant(role, addr string) {
./core/access_control.go:27:func (a *AccessController) Revoke(role, addr string) {
./core/access_control.go:39:func (a *AccessController) HasRole(role, addr string) bool {
./core/access_control.go:51:func (a *AccessController) List(addr string) []string {
./core/block.go:20:func NewSubBlock(txs []*Transaction, validator string) *SubBlock {
./core/block.go:29:func (sb *SubBlock) Hash() string {
./core/block.go:40:func (sb *SubBlock) VerifySignature() bool {
./core/block.go:55:func NewBlock(subBlocks []*SubBlock, prevHash string) *Block {
./core/block.go:61:func (b *Block) HeaderHash(nonce uint64) string {
./core/block.go:71:func signSubBlock(validator, msg string) string {
./content_types.go:23:func NewContentMeta(id, name string, size int64, hash string) ContentMeta {
./core/network.go:24:func NewNetwork(auth *BiometricService) *Network {
./core/network.go:36:func (n *Network) Start() {
./core/network.go:50:func (n *Network) Stop() {
./core/network.go:66:func (n *Network) AddNode(node *Node) {
./core/network.go:73:func (n *Network) AddRelay(node *Node) {
./core/network.go:80:func (n *Network) Peers() []string {
./core/network.go:94:func (n *Network) EnqueueTransaction(tx *Transaction) {
./core/network.go:107:func (n *Network) Broadcast(tx *Transaction, userID string, biometric []byte) error {
./core/network.go:117:func (n *Network) Subscribe(topic string) <-chan []byte {
./core/network.go:127:func (n *Network) Publish(topic string, data []byte) {
./core/network.go:142:func (n *Network) processQueue() {
./core/network.go:157:func (n *Network) broadcast(tx *Transaction) {
./core/loanpool_views.go:20:func NewLoanProposalView(p *LoanProposal) LoanProposalView {
./core/loanpool_views.go:36:func (lp *LoanPool) ProposalInfo(id uint64) (LoanProposalView, bool) {
./core/loanpool_views.go:45:func (lp *LoanPool) ProposalViews() []LoanProposalView {
./core/loanpool_views.go:67:func NewLoanApplicationView(a *LoanApplication) LoanApplicationView {
./core/loanpool_views.go:81:func (l *LoanPoolApply) ApplicationInfo(id uint64) (LoanApplicationView, bool) {
./core/loanpool_views.go:90:func (l *LoanPoolApply) ApplicationViews() []LoanApplicationView {
./compliance.go:52:func NewComplianceService() *ComplianceService {
./compliance.go:62:func (s *ComplianceService) ValidateKYC(address string, kycData []byte) (string, error) {
./compliance.go:76:func (s *ComplianceService) EraseKYC(address string) {
./compliance.go:84:func (s *ComplianceService) RecordFraud(address string, severity int) {
./compliance.go:95:func (s *ComplianceService) RiskScore(address string) int {
./compliance.go:103:func (s *ComplianceService) AuditTrail(address string) []AuditEntry {
./compliance.go:115:func (s *ComplianceService) MonitorTransaction(tx ComplianceTransaction, threshold float64) bool {
./compliance.go:127:func (s *ComplianceService) VerifyZKP(blob []byte, commitmentHex, proofHex string) bool {
./compliance.go:132:func (s *ComplianceService) appendAudit(addr, event string, metadata map[string]string) {
./core/loanpool.go:18:func NewLoanPool(treasury uint64) *LoanPool {
./core/loanpool.go:27:func (lp *LoanPool) SubmitProposal(creator, recipient, typ string, amount uint64, desc string) (uint64, error) {
./core/loanpool.go:38:func (lp *LoanPool) VoteProposal(voter string, id uint64) error {
./core/loanpool.go:51:func (lp *LoanPool) Tick() {
./core/loanpool.go:61:func (lp *LoanPool) Disburse(id uint64) error {
./core/loanpool.go:78:func (lp *LoanPool) GetProposal(id uint64) (*LoanProposal, bool) {
./core/loanpool.go:84:func (lp *LoanPool) ListProposals() []*LoanProposal {
./core/loanpool.go:94:func (lp *LoanPool) CancelProposal(creator string, id uint64) error {
./core/loanpool.go:107:func (lp *LoanPool) ExtendProposal(creator string, id uint64, hrs int) error {
./core/ledger.go:36:func NewLedger(path ...string) *Ledger {
./core/ledger.go:52:func (l *Ledger) replayWAL() {
./core/ledger.go:72:func (l *Ledger) appendWAL(b *Block) {
./core/ledger.go:85:func (l *Ledger) Head() (int, string) {
./core/ledger.go:96:func (l *Ledger) GetBlock(height int) (*Block, bool) {
./core/ledger.go:106:func (l *Ledger) AddBlock(b *Block) {
./core/ledger.go:114:func (l *Ledger) GetBalance(addr string) uint64 {
./core/ledger.go:121:func (l *Ledger) GetUTXOs(addr string) []UTXO {
./core/ledger.go:133:func (l *Ledger) Credit(addr string, amount uint64) {
./core/ledger.go:142:func (l *Ledger) Mint(addr string, amount uint64) {
./core/ledger.go:148:func (l *Ledger) Transfer(from, to string, amount, fee uint64) error {
./core/ledger.go:156:func (l *Ledger) ApplyTransaction(tx *Transaction) error {
./core/ledger.go:171:func (l *Ledger) AddToPool(tx *Transaction) {
./core/ledger.go:178:func (l *Ledger) Pool() []*Transaction {
./core/ledger.go:186:func (l *Ledger) newUTXO(amount uint64) *UTXO {
./core/ledger.go:192:func (l *Ledger) updateUTXO(addr string) {
./ai_training.go:28:func NewTrainingManager() *TrainingManager {
./ai_training.go:33:func (m *TrainingManager) Start(datasetCID, modelCID string) string {
./ai_training.go:49:func (m *TrainingManager) Status(id string) (TrainingJob, bool) {
./ai_training.go:57:func (m *TrainingManager) List() []TrainingJob {
./ai_training.go:68:func (m *TrainingManager) Cancel(id string) error {
./core/base_node.go:19:func NewBaseNode(id nodes.Address) *BaseNode {
./core/base_node.go:27:func (n *BaseNode) ID() nodes.Address { return n.id }
./core/base_node.go:30:func (n *BaseNode) Start() error {
./core/base_node.go:41:func (n *BaseNode) Stop() error {
./core/base_node.go:52:func (n *BaseNode) IsRunning() bool {
./core/base_node.go:59:func (n *BaseNode) Peers() []nodes.Address {
./core/base_node.go:70:func (n *BaseNode) DialSeed(addr nodes.Address) error {
./core/immutability_enforcement.go:12:func NewImmutabilityEnforcer(genesis *Block) *ImmutabilityEnforcer {
./core/immutability_enforcement.go:22:func (i *ImmutabilityEnforcer) CheckLedger(l *Ledger) error {
./ai_enhanced_contract.go:19:func NewAIContractRegistry(base *ContractRegistry) *AIContractRegistry {
./ai_enhanced_contract.go:28:func (r *AIContractRegistry) DeployAIContract(wasm []byte, modelHash, manifest string, gasLimit uint64, owner string) (string, error) {
./ai_enhanced_contract.go:41:func (r *AIContractRegistry) InvokeAIContract(addr string, input []byte, gasLimit uint64) ([]byte, uint64, error) {
./ai_enhanced_contract.go:49:func (r *AIContractRegistry) ModelHash(addr string) (string, bool) {
./core/high_availability.go:20:func NewFailoverManager(primary string, timeout time.Duration) *FailoverManager {
./core/high_availability.go:29:func (m *FailoverManager) RegisterBackup(id string) {
./core/high_availability.go:36:func (m *FailoverManager) Heartbeat(id string) {
./core/high_availability.go:45:func (m *FailoverManager) Active() string {
./access_control.go:12:func NewAccessController() *AccessController {
./access_control.go:17:func (a *AccessController) Grant(role, addr string) {
./access_control.go:27:func (a *AccessController) Revoke(role, addr string) {
./access_control.go:39:func (a *AccessController) HasRole(role, addr string) bool {
./access_control.go:51:func (a *AccessController) List(addr string) []string {
./core/gas_table.go:20:func DefaultGasTable() GasTable {
./core/gas_table.go:36:func parseGasGuide() map[string]uint64 {
./core/gas_table.go:70:func SetGasCost(op Opcode, cost uint64) {
./core/gas_table.go:76:func GasTableSnapshot() GasTable {
./core/firewall.go:14:func NewFirewall() *Firewall {
./core/firewall.go:23:func (f *Firewall) Allow(ip string) {
./core/firewall.go:32:func (f *Firewall) Block(ip string) {
./core/firewall.go:42:func (f *Firewall) IsAllowed(ip string) bool {
./core/firewall.go:56:func (f *Firewall) Rules() (allowed []string, blocked []string) {
./biometrics_auth.go:15:func NewBiometricsAuth() *BiometricsAuth {
./biometrics_auth.go:20:func (b *BiometricsAuth) Enroll(addr string, biometric []byte) {
./biometrics_auth.go:27:func (b *BiometricsAuth) Verify(addr string, biometric []byte) bool {
./biometrics_auth.go:38:func (b *BiometricsAuth) Remove(addr string) {
./biometrics_auth.go:45:func (b *BiometricsAuth) Enrolled(addr string) bool {
./biometrics_auth.go:54:func (b *BiometricsAuth) List() []string {
./ai_secure_storage.go:19:func NewSecureStorage() *SecureStorage {
./ai_secure_storage.go:24:func (s *SecureStorage) Store(hash string, data, key []byte) error {
./ai_secure_storage.go:45:func (s *SecureStorage) Retrieve(hash string, key []byte) ([]byte, error) {
./core/dao_token.go:15:func NewDAOTokenLedger() *DAOTokenLedger {
./core/dao_token.go:20:func (l *DAOTokenLedger) Mint(addr string, amount uint64) {
./core/dao_token.go:27:func (l *DAOTokenLedger) Transfer(from, to string, amount uint64) error {
./core/dao_token.go:39:func (l *DAOTokenLedger) Balance(addr string) uint64 {
./ai_drift_monitor.go:15:func NewDriftMonitor() *DriftMonitor {
./ai_drift_monitor.go:20:func (d *DriftMonitor) UpdateBaseline(modelHash string, metric float64) {
./ai_drift_monitor.go:27:func (d *DriftMonitor) HasDrift(modelHash string, metric, threshold float64) bool {
./core/ai_enhanced_contract.go:19:func NewAIContractRegistry(base *ContractRegistry) *AIContractRegistry {
./core/ai_enhanced_contract.go:28:func (r *AIContractRegistry) DeployAIContract(wasm []byte, modelHash, manifest string, gasLimit uint64, owner string) (string, error) {
./core/ai_enhanced_contract.go:41:func (r *AIContractRegistry) InvokeAIContract(addr string, input []byte, gasLimit uint64) ([]byte, uint64, error) {
./core/ai_enhanced_contract.go:49:func (r *AIContractRegistry) ModelHash(addr string) (string, bool) {
./core/authority_node_index.go:12:func NewAuthorityNodeIndex() *AuthorityNodeIndex {
./core/authority_node_index.go:17:func (idx *AuthorityNodeIndex) Add(node *AuthorityNode) {
./core/authority_node_index.go:27:func (idx *AuthorityNodeIndex) Get(addr string) (*AuthorityNode, bool) {
./core/authority_node_index.go:35:func (idx *AuthorityNodeIndex) Remove(addr string) {
./core/authority_node_index.go:42:func (idx *AuthorityNodeIndex) List() []*AuthorityNode {
./content_node_impl.go:24:func NewContentNode(key []byte) (*ContentNode, error) {
./content_node_impl.go:36:func (n *ContentNode) StoreContent(name string, data []byte) (ContentMeta, error) {
./content_node_impl.go:64:func (n *ContentNode) RetrieveContent(id string) ([]byte, bool, error) {
./content_node_impl.go:93:func (n *ContentNode) Meta(id string) (ContentMeta, bool) {
./content_node_impl.go:101:func (n *ContentNode) DeleteContent(id string) {
./contracts_opcodes.go:1414:func opcodeByName(name string) uint32 {
./core/consensus_difficulty.go:17:func NewDifficultyManager(engine *SynnergyConsensus, window int, initial, target float64) *DifficultyManager {
./core/consensus_difficulty.go:26:func (dm *DifficultyManager) AddSample(duration float64) float64 {
./core/consensus_difficulty.go:45:func (dm *DifficultyManager) Difficulty() float64 {
```
